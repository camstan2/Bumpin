import SwiftUI
import MapKit
import CoreLocation
import FirebaseFirestore
import FirebaseAuth // Added for Auth.auth()

// MARK: - Filter Enums
enum PartyFilter: String, CaseIterable {
    case normal = "Normal"
    case closest = "Closest"
    case longestRunning = "Longest Running"
    case recentlyStarted = "Recently Started"
    case mostMembers = "Most Members"
    case mostFollowers = "Most Followers"
    
    var icon: String {
        switch self {
        case .normal: return "star"
        case .closest: return "location"
        case .longestRunning: return "clock"
        case .recentlyStarted: return "sparkles"
        case .mostMembers: return "person.3"
        case .mostFollowers: return "person.2"
        }
    }
}



// MARK: - Party Discovery View
struct PartyDiscoveryView: View {
    @Environment(\.scenePhase) private var scenePhase
    @StateObject private var locationManager = LocationManager()
    @StateObject private var discoveryManager = PartyDiscoveryManager()
    @EnvironmentObject var partyManager: PartyManager
    
    @State private var selectedTab = 0
    @State private var showingMap = false
    @State private var nearbyDistanceSlider: Double = 0.25 // Default to 0.25 miles
    
    // Filter state
    @State private var showingFilters = false
    @State private var selectedFilter: PartyFilter = .normal
    
    // Topics state
    @State private var topicChats: [TopicChat] = []
    @State private var isLoadingTopics = false
    
    @State private var region = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194), // Default to San Francisco
        span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)
    )
    @State private var cameraPosition: MapCameraPosition = .region(
        MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),
            span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)
        )
    )
    
    @State private var showUserSearch = false
    @StateObject private var musicAuthManager = MusicAuthorizationManager()
    @State private var showAllLiveDJs: Bool = false
    
    // Missing state variables
    @State private var selectedParty: Party?
    @State private var showingPartyDetail = false
    @State private var showingMapFilters = false
    
    // Topics expansion states
    @State private var expandedTrendingTopics = false
    @State private var expandedMovieTopics = false
    @State private var expandedSportsTopics = false
    @State private var expandedGamingTopics = false
    @State private var expandedPoliticsTopics = false
    
    // Topics "See All" sheet states
    @State private var showingTrendingTopicsAll = false
    @State private var showingMovieTopicsAll = false
    @State private var showingSportsTopicsAll = false
    @State private var showingGamingTopicsAll = false
    @State private var showingPoliticsTopicsAll = false

    // Topics preview state
    @State private var selectedTopic: TopicChat? = nil
    // Deprecated: using .sheet(item:) with selectedTopic instead
    
    // Topics search state
    @State private var searchText = ""
    @State private var isSearching = false
    
    // Topics genre customization state
    @State private var showingGenreCustomization = false
    @State private var enabledCategories: Set<TopicCategory> = Set(TopicCategory.defaultCategories)
    
    // Explore section "See More" states
    @State private var showMoreTrending = false
    @State private var showMoreInfluencers = false
    @State private var showMoreDJs = false
    
    // Explore section "See All" sheet states
    @State private var showingTrendingPartiesAll = false
    @State private var showingInfluencerPartiesAll = false
    @State private var showingDJPartiesAll = false
    
    // Expanded states for inline expansion
    @State private var expandedTrending = false
    @State private var expandedInfluencers = false
    @State private var expandedDJs = false
    
    // Live DJs Section
    @State private var liveSessions: [LiveDJSession] = []
    @State private var isLoadingLiveSessions = false
    @StateObject private var djStreamingManager = DJStreamingManager.shared
    @State private var liveSessionsListener: ListenerRegistration? = nil
    @State private var liveSessionsError: String? = nil
    
    // MARK: - Filtered Parties
    private var filteredFollowingParties: [Party] {
        let result: [Party]
        if searchText.isEmpty {
            result = Array(discoveryManager.followingParties.prefix(discoveryManager.followingDisplayCount))
        } else {
            result = discoveryManager.followingParties.filter { party in
                party.name.localizedCaseInsensitiveContains(searchText) ||
                party.hostName.localizedCaseInsensitiveContains(searchText)
            }
        }
        return sortParties(result, by: selectedFilter)
    }
    
    private var filteredFriendsParties: [Party] {
        let result: [Party]
        if searchText.isEmpty {
            result = discoveryManager.friendsParties
        } else {
            result = discoveryManager.friendsParties.filter { party in
                party.name.localizedCaseInsensitiveContains(searchText) ||
                party.hostName.localizedCaseInsensitiveContains(searchText)
            }
        }
        return sortParties(result, by: selectedFilter)
    }
    
    private var filteredNearbyParties: [Party] {
        var result: [Party]
        
        #if DEBUG
        if UserDefaults.standard.bool(forKey: "discovery.mockData") {
            // If mock data is enabled, show all parties regardless of location
            if searchText.isEmpty {
                result = Array(discoveryManager.nearbyParties.prefix(20))
            } else {
                result = discoveryManager.nearbyParties.filter { party in
                    party.name.localizedCaseInsensitiveContains(searchText) ||
                    party.hostName.localizedCaseInsensitiveContains(searchText)
                }
            }
        } else {
            // Normal filtering logic for real data
            if searchText.isEmpty {
                result = Array(discoveryManager.nearbyParties.prefix(20)).filter { party in
                    // Filter by distance based on slider value
                    if let userLocation = locationManager.currentLocation,
                       let latitude = party.latitude,
                       let longitude = party.longitude {
                        let partyLocation = CLLocation(latitude: latitude, longitude: longitude)
                        let distance = userLocation.distance(from: partyLocation) / 1609.34 // Convert meters to miles
                        return distance <= nearbyDistanceSlider
                    }
                    // If no location available, show all parties
                    return true
                }
            } else {
                result = discoveryManager.nearbyParties.filter { party in
                    let nameMatch = party.name.localizedCaseInsensitiveContains(searchText) ||
                    party.hostName.localizedCaseInsensitiveContains(searchText)
                    
                    // Also filter by distance based on slider value
                    if let userLocation = locationManager.currentLocation,
                       let latitude = party.latitude,
                       let longitude = party.longitude {
                        let partyLocation = CLLocation(latitude: latitude, longitude: longitude)
                        let distance = userLocation.distance(from: partyLocation) / 1609.34 // Convert meters to miles
                        return nameMatch && distance <= nearbyDistanceSlider
                    }
                    // If no location available, just filter by name match
                    return nameMatch
                }
            }
        }
        #else
        // Normal filtering logic for real data
        if searchText.isEmpty {
            result = Array(discoveryManager.nearbyParties.prefix(20)).filter { party in
                // Filter by distance based on slider value
                if let userLocation = locationManager.currentLocation,
                   let latitude = party.latitude,
                   let longitude = party.longitude {
                    let partyLocation = CLLocation(latitude: latitude, longitude: longitude)
                    let distance = userLocation.distance(from: partyLocation) / 1609.34 // Convert meters to miles
                    return distance <= nearbyDistanceSlider
                }
                // If no location available, show all parties
                return true
            }
        } else {
            result = discoveryManager.nearbyParties.filter { party in
                let nameMatch = party.name.localizedCaseInsensitiveContains(searchText) ||
                party.hostName.localizedCaseInsensitiveContains(searchText)
                
                // Also filter by distance based on slider value
                if let userLocation = locationManager.currentLocation,
                   let latitude = party.latitude,
                   let longitude = party.longitude {
                    let partyLocation = CLLocation(latitude: latitude, longitude: longitude)
                    let distance = userLocation.distance(from: partyLocation) / 1609.34 // Convert meters to miles
                    return nameMatch && distance <= nearbyDistanceSlider
                }
                // If no location available, just filter by name match
                return nameMatch
            }
        }
        #endif
        

        
        // Apply sorting based on selected filter
        result = sortParties(result, by: selectedFilter)
        
        print("ðŸ” Filtered nearby parties: \(result.count) out of \(discoveryManager.nearbyParties.count) total")
        return result
    }
    
    // MARK: - Sorting Function
    private func sortParties(_ parties: [Party], by filter: PartyFilter) -> [Party] {
        switch filter {
        case .normal:
            // Algorithm combining popularity and recency
            return parties.sorted { (party1: Party, party2: Party) -> Bool in
                let score1 = calculateNormalScore(for: party1)
                let score2 = calculateNormalScore(for: party2)
                return score1 > score2
            }
            
        case .closest:
            guard let userLocation = locationManager.currentLocation else { return parties }
            return parties.sorted { (party1: Party, party2: Party) -> Bool in
                let distance1 = getDistance(from: userLocation, to: party1)
                let distance2 = getDistance(from: userLocation, to: party2)
                return distance1 < distance2
            }
            
        case .longestRunning:
            return parties.sorted { (party1: Party, party2: Party) -> Bool in
                party1.createdAt < party2.createdAt
            }
            
        case .recentlyStarted:
            return parties.sorted { (party1: Party, party2: Party) -> Bool in
                party1.createdAt > party2.createdAt
            }
            
        case .mostMembers:
            return parties.sorted { (party1: Party, party2: Party) -> Bool in
                party1.participants.count > party2.participants.count
            }
            
        case .mostFollowers:
            return parties.sorted { (party1: Party, party2: Party) -> Bool in
                // Use followerCount if available, otherwise use participants count as proxy
                let followers1 = party1.followerCount ?? party1.participants.count
                let followers2 = party2.followerCount ?? party2.participants.count
                return followers1 > followers2
            }
        }
    }
    
    // MARK: - Normal Algorithm Score Calculation
    private func calculateNormalScore(for party: Party) -> Double {
        let now = Date()
        let timeSinceCreation = now.timeIntervalSince(party.createdAt)
        let hoursSinceCreation = timeSinceCreation / 3600 // Convert to hours
        
        // Popularity score (0-100)
        let popularityScore = min(100.0, Double(party.participants.count) * 10.0 + Double(party.followerCount ?? 0) * 0.1)
        
        // Recency score (0-100) - newer parties get higher scores
        let recencyScore = max(0.0, 100.0 - (hoursSinceCreation * 2.0)) // Decay over time
        
        // Combine scores with weights (60% popularity, 40% recency)
        let finalScore = (popularityScore * 0.6) + (recencyScore * 0.4)
        
        return finalScore
    }
    
    private func getDistance(from userLocation: CLLocation, to party: Party) -> Double {
        guard let latitude = party.latitude,
              let longitude = party.longitude else {
            return Double.infinity
        }
        
        let partyLocation = CLLocation(latitude: latitude, longitude: longitude)
        return userLocation.distance(from: partyLocation)
    }
    
    private var filteredExploreParties: [Party] {
        let result: [Party]
        if searchText.isEmpty {
            result = Array(discoveryManager.exploreParties.prefix(20))
        } else {
            result = discoveryManager.exploreParties.filter { party in
                party.name.localizedCaseInsensitiveContains(searchText) ||
                party.hostName.localizedCaseInsensitiveContains(searchText)
            }
        }
        return sortParties(result, by: selectedFilter)
    }
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Top tabs bar with actions
                topTabsBar
                
                // Tab View (Topics removed)
                TabView(selection: $selectedTab) {
                    // Following Tab
                    followingTabView
                        .tag(0)
                    
                    // Friends Tab
                    friendsTabView
                        .tag(1)
                    
                    // Proximity Tab (18+ only)
                    proximityTabView
                        .tag(2)
                    
                    // Explore Tab (moved from tag 4 to tag 3)
                    exploreTabView
                        .tag(3)
                }
                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
                .animation(.easeInOut(duration: 0.3), value: selectedTab)
                .onChange(of: selectedTab) { _, newTab in
                    discoveryManager.setActiveTab(index: newTab)
                    AnalyticsService.shared.logDiscoveryTabView(tab: tabName(newTab))
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
            .navigationBarHidden(true)
            .background(Color(.systemBackground))
            .onAppear {
                Task {
                    #if DEBUG
                    // Enable mock data by default in debug builds if not already set
                    if UserDefaults.standard.object(forKey: "discovery.mockData") == nil {
                        UserDefaults.standard.set(true, forKey: "discovery.mockData")
                    }
                    
                    if UserDefaults.standard.bool(forKey: "discovery.mockData") {
                        await MainActor.run { discoveryManager.isLoading = true }
                        discoveryManager.stopDiscovery()
                        discoveryManager.followingParties = []
                        discoveryManager.friendsParties = []
                        discoveryManager.nearbyParties = []
                        discoveryManager.exploreParties = []
                        discoveryManager.performMockLoad()
                        print("ðŸŽ‰ Mock data loaded on app start")
                    } else {
                        // If mock data is not explicitly enabled, still load it if no location is available
                        // This ensures the UI shows data for testing
                        await setupLocationServices()
                        if locationManager.currentLocation == nil {
                            discoveryManager.performMockLoad()
                            print("ðŸŽ‰ Mock data loaded due to no location")
                        }
                    }
                    #else
                    await setupLocationServices()
                    #endif
                    
                    // Load enabled categories and topics
                    loadEnabledCategories()
                    await loadTopicChats()
                }
                AnalyticsService.shared.logDiscoveryTabView(tab: tabName(selectedTab))
            }
            .onDisappear {
                discoveryManager.stopDiscovery()
                AnalyticsService.shared.logDiscoveryLifecycle(action: "pause")
            }
            .onChange(of: scenePhase) { _, newPhase in
                switch newPhase {
                case .active:
                    Task { await discoveryManager.resumeIfNeeded(locationManager: locationManager) }
                    AnalyticsService.shared.logDiscoveryLifecycle(action: "resume")
                case .inactive, .background:
                    discoveryManager.stopDiscovery()
                    AnalyticsService.shared.logDiscoveryLifecycle(action: "pause")
                @unknown default:
                    break
                }
            }
        }
        // Respect bottom safe area so dots/FAB align relative to tab bar
        // Restore connectivity banner (minimal height); ensure content starts at top
        .safeAreaInset(edge: .top) { ConnectivityBanner() }
        .onReceive(NotificationCenter.default.publisher(for: Notification.Name("DiscoveryRetryRequested"))) { _ in
            discoveryManager.manualRetry()
        }
        .onAppear { startLiveSessionsListener() }
        .onDisappear { stopLiveSessionsListener() }
        .sheet(isPresented: $showingPartyDetail) {
            if let party = selectedParty {
                EnhancedPartyDetailView(party: party) {
                    discoveryManager.quickJoinParty(party)
                }
            }
        }
        .sheet(isPresented: $showingMapFilters) {
            MapFiltersView(
                selectedFilter: $discoveryManager.mapFilter,
                onApply: applyMapFilters
            )
        }
        .sheet(isPresented: $showingFilters) {
            FilterSheetView(
                selectedFilter: $selectedFilter
            )
        }
        .sheet(isPresented: $showUserSearch) {
            UserSearchView()
        }
        // Create Party sheet (gated by Apple Music authorization)
        .sheet(isPresented: $partyManager.showPartyCreation) {
            if musicAuthManager.isAuthorized {
                PartyCreationView(partyManager: partyManager)
            } else {
                VStack(spacing: 16) {
                    Image(systemName: "music.note")
                        .font(.system(size: 40))
                        .foregroundColor(.blue)
                    Text("Apple Music Access Required")
                        .font(.headline)
                        .fontWeight(.semibold)
                    Text("Grant access to create and sync parties.")
                        .font(.body)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                    Button(action: { Task { await musicAuthManager.requestMusicAuthorization() } }) {
                        HStack { Image(systemName: "music.note"); Text("Grant Apple Music Access") }
                            .font(.headline)
                        .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .cornerRadius(12)
                    }
                    .padding(.horizontal)
                }
                .padding()
            }
        }
        // Floating Action Button
        .overlay(alignment: .bottomTrailing) {
            PlusFAB { partyManager.showPartyCreation = true }
                .padding(.trailing, 20)
                .padding(.bottom, 8)
                .accessibilityLabel("Create Party")
        }
    }
    
    // MARK: - Top Tabs Bar (edge-to-edge)
    private var topTabsBar: some View {
        VStack(spacing: 0) {
            // Tabs row (button-based) - Topics removed
            HStack(spacing: 6) {
                Button(action: { selectedTab = 0 }) {
                    Text("Following").font(.caption).fontWeight(selectedTab == 0 ? .semibold : .regular)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 6)
                        .background(RoundedRectangle(cornerRadius: 8).fill(Color(.systemGray6)))
                }
                Button(action: { selectedTab = 1 }) {
                    Text("Friends").font(.caption).fontWeight(selectedTab == 1 ? .semibold : .regular)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 6)
                        .background(RoundedRectangle(cornerRadius: 8).fill(Color(.systemGray6)))
                }
                Button(action: { selectedTab = 2 }) {
                    Text("Nearby").font(.caption).fontWeight(selectedTab == 2 ? .semibold : .regular)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 6)
                        .background(RoundedRectangle(cornerRadius: 8).fill(Color(.systemGray6)))
                }
                Button(action: { selectedTab = 3 }) {
                    Text("Explore").font(.caption).fontWeight(selectedTab == 3 ? .semibold : .regular)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 6)
                        .background(RoundedRectangle(cornerRadius: 8).fill(Color(.systemGray6)))
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding(.horizontal, 16)
            .padding(.top, 8)
            .padding(.bottom, 4)
            
            // Search Bar and Actions
            HStack(spacing: 12) {
                HStack(spacing: 8) {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.secondary)
                        .font(.system(size: 16))
                    
                    TextField("Search parties or hosts...", text: $searchText)
                        .textFieldStyle(PlainTextFieldStyle())
                        .font(.subheadline)
                    
                    if !searchText.isEmpty {
                        Button(action: {
                            searchText = ""
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(.secondary)
                                .font(.system(size: 16))
                        }
                    }
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(Color(.systemGray6))
                .cornerRadius(10)
                
                // Actions
                Button(action: { Task { await discoveryManager.refreshParties() } }) { 
                    Image(systemName: "arrow.clockwise").font(.caption) 
                }
                .padding(.horizontal, 6)
                
                #if DEBUG
                Button(UserDefaults.standard.bool(forKey: "discovery.mockData") ? "Mock: On" : "Mock: Off") {
                    let new = !UserDefaults.standard.bool(forKey: "discovery.mockData")
                    UserDefaults.standard.set(new, forKey: "discovery.mockData")
                    if new {
                        discoveryManager.stopDiscovery()
                        discoveryManager.performMockLoad()
                    } else {
                        Task { await setupLocationServices() }
                    }
                }
                .font(.caption2)
                .foregroundColor(.purple)
                .padding(.horizontal, 6)
                
                Button("Debug") {
                    print("ðŸ” Debug Info:")
                    print("  - Mock data enabled: \(UserDefaults.standard.bool(forKey: "discovery.mockData"))")
                    print("  - Nearby parties count: \(discoveryManager.nearbyParties.count)")
                    print("  - Filtered nearby parties count: \(filteredNearbyParties.count)")
                    print("  - Current tab: \(selectedTab)")
                    print("  - Distance slider: \(nearbyDistanceSlider)")
                }
                .font(.caption2)
                .foregroundColor(.orange)
                .padding(.horizontal, 6)
                
                Button("Test Nearby") {
                    UserDefaults.standard.set(true, forKey: "discovery.mockData")
                    discoveryManager.stopDiscovery()
                    discoveryManager.performMockLoad()
                    selectedTab = 2 // Switch to nearby tab
                }
                .font(.caption2)
                .foregroundColor(.green)
                .padding(.horizontal, 6)
                #endif
                
                Button(action: { showingFilters.toggle() }) { 
                    Image(systemName: "line.3.horizontal.decrease.circle").font(.caption) 
                }
                .padding(.horizontal, 6)
                
                Button(action: { showingMap.toggle() }) { 
                    Image(systemName: showingMap ? "list.bullet" : "map").font(.caption) 
                }
                .padding(.horizontal, 6)
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 8)
            .background(Color(.systemBackground))
        }
    }
    
    // MARK: - Following Tab
    private var followingTabView: some View {
        VStack(spacing: 0) {
            if showingMap {
                mapView
            } else {
                partyListView(parties: filteredFollowingParties)
            }
        }
    }
    
    // MARK: - Friends Tab
    private var friendsTabView: some View {
        VStack(spacing: 0) {
            if showingMap {
                mapView
            } else {
                ScrollView {
                    VStack(spacing: 24) {
                        friendsPartiesSection
                    }
                }
            }
        }
    }
    
    // MARK: - Friends List Section
    private var friendsListSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text("Your Friends")
                    .font(.headline)
                    .fontWeight(.bold)
                
                Spacer()
                
                if discoveryManager.isLoadingFriends {
                    ProgressView()
                        .scaleEffect(0.8)
                }
            }
            
            if discoveryManager.friends.isEmpty && !discoveryManager.isLoadingFriends {
                VStack(spacing: 16) {
                    Image(systemName: "person.3.fill")
                        .font(.system(size: 30))
                        .foregroundColor(.gray)
                    
                    Text("No Friends Yet")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    Text("Follow people to see their parties here")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 24)
            } else {
                LazyVStack(spacing: 12) {
                    ForEach(discoveryManager.friends) { friend in
                        FriendRowView(
                            friend: friend,
                            status: (discoveryManager.friendsParties.contains { $0.hostId == friend.uid } ? .online : .offline),
                            isLocationSharing: discoveryManager.isLocationSharingWith(friendId: friend.uid),
                            onToggleLocationSharing: {
                                discoveryManager.toggleLocationSharing(for: friend.uid)
                            }
                        )
                    }
                }
            }
        }
        .padding(.horizontal, 0)
        .padding(.vertical, 20)
        .background(Color(.systemBackground))
        .cornerRadius(16)
    }
    
    // MARK: - Friends Parties Section
    private var friendsPartiesSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            if filteredFriendsParties.isEmpty && !discoveryManager.isLoading {
                VStack(spacing: 16) {
                    Image(systemName: "music.note.list")
                        .font(.system(size: 48))
                        .foregroundColor(.secondary)
                    
                    Text("No Friends' Parties")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Text("When your friends create parties, they'll appear here")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .padding(.vertical, 40)
            } else {
                LazyVStack(spacing: 16) {
                    ForEach(filteredFriendsParties) { party in
                        PartyCard(
                            party: party,
                            currentLocation: locationManager.currentLocation,
                            onJoin: {
                                discoveryManager.quickJoinParty(party)
                            },
                            isNearbyParty: false
                        )
                    }
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 16)
            }
        }
    }
    
    // MARK: - Proximity Tab
    private var proximityTabView: some View {
        VStack(spacing: 16) {
            // Distance Slider
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    Text("Distance")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Spacer()
                    
                    Text("\(String(format: "%.2f", nearbyDistanceSlider)) miles")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                
                Slider(value: $nearbyDistanceSlider, in: 0.25...5.0, step: 0.25)
                    .accentColor(.yellow)
                
                HStack {
                    Text("0.25 mi")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Spacer()
                    
                    Text("5.0 mi")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color(.systemGray6))
            .cornerRadius(12)
            .padding(.horizontal, 16)
            
            // Party List
            if showingMap {
                mapView
            } else {
                if filteredNearbyParties.isEmpty {
                    // Empty state
                    VStack(spacing: 16) {
                        Spacer()
                        Image(systemName: "location.slash")
                            .font(.system(size: 40))
                            .foregroundColor(.gray)
                        Text("No parties nearby")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        Text("Try adjusting the distance slider or check back later!")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal)
                        Spacer()
                    }
                } else {
                    nearbyPartyListView(parties: filteredNearbyParties)
                }
            }
        }
    }
    
    // MARK: - Age Verification View
    private var ageVerificationView: some View {
        VStack(spacing: 24) {
            Spacer()
            
            VStack(spacing: 16) {
                Image(systemName: "person.2.circle")
                    .font(.system(size: 60))
                    .foregroundColor(.purple)
                
                Text("Age Verification Required")
                    .font(.title2)
                    .fontWeight(.bold)
                
                Text("Proximity features are only available to users 18 and older. This helps ensure a safe environment for location-based discovery.")
                    .font(.body)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
            }
            
            VStack(spacing: 16) {
                Button(action: {
                    discoveryManager.verifyAge()
                }) {
                    HStack(spacing: 8) {
                        Image(systemName: "checkmark.circle")
                            .font(.title3)
                        Text("I am 18 or older")
                            .font(.headline)
                            .fontWeight(.semibold)
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.purple)
                    .cornerRadius(12)
                }
                
                Button(action: {
                    // Show age verification alert
                    discoveryManager.showAgeVerificationAlert = true
                }) {
                    Text("Learn More")
                        .font(.subheadline)
                        .foregroundColor(.purple)
                }
            }
            .padding(.horizontal)
            
            Spacer()
        }
        .alert("Age Verification", isPresented: $discoveryManager.showAgeVerificationAlert) {
            Button("OK") { }
        } message: {
            Text("Proximity features allow you to discover parties within 0.25 miles of your location. This feature is restricted to users 18 and older for safety reasons.")
        }
    }
    
    // MARK: - Proximity Content
    private var proximityContent: some View {
        VStack(spacing: 0) {
            // Proximity Settings Header
            proximitySettingsHeader
            
            // Tab Header with Quick Preview
            tabHeaderView(
                title: "Nearby",
                icon: "location.fill",
                count: filteredNearbyParties.count,
                description: "Parties within \(String(format: "%.2f", nearbyDistanceSlider)) miles"
            )
            
            if showingMap {
                mapView
            } else {
                nearbyPartyListView(parties: filteredNearbyParties)
            }
        }
        .alert("Location Validation Failed", isPresented: $discoveryManager.locationValidationFailed) {
            Button("OK") {
                discoveryManager.locationValidationFailed = false
            }
        } message: {
            Text("We couldn't validate your location. This might be due to location spoofing or GPS issues. Proximity discovery has been disabled for your safety.")
        }
    }
    
    // MARK: - Proximity Settings Header
    private var proximitySettingsHeader: some View {
        VStack(spacing: 12) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    HStack(spacing: 8) {
                        Image(systemName: "location.fill")
                            .foregroundColor(.blue)
                            .font(.title2)
                        
                        Text("Proximity Discovery")
                            .font(.headline)
                            .fontWeight(.bold)
                    }
                    
                    Text("Discover parties within 0.25 miles")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                // Privacy Toggle
                Toggle("", isOn: $discoveryManager.isProximityDiscoveryEnabled)
                    .toggleStyle(SwitchToggleStyle(tint: .purple))
                    .onChange(of: discoveryManager.isProximityDiscoveryEnabled) { _, newValue in
                        discoveryManager.updateProximitySettings(enabled: newValue)
                    }
            }
            
            // Privacy Status
            HStack(spacing: 8) {
                Image(systemName: discoveryManager.isProximityDiscoveryEnabled ? "eye.fill" : "eye.slash.fill")
                    .foregroundColor(discoveryManager.isProximityDiscoveryEnabled ? .green : .gray)
                    .font(.caption)
                
                Text(discoveryManager.isProximityDiscoveryEnabled ? "Your location is visible to nearby users" : "Your location is private")
                    .font(.caption)
                    .foregroundColor(discoveryManager.isProximityDiscoveryEnabled ? .green : .gray)
                
                Spacer()
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(discoveryManager.isProximityDiscoveryEnabled ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
            )
            
            // Radius control
            HStack(spacing: 12) {
                Text("Radius")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Slider(value: Binding(
                    get: { discoveryManager.proximityRadius },
                    set: { discoveryManager.proximityRadius = $0 }
                ), in: 402.336...8046.72, step: 201.168)
                Text(String(format: "%.2f mi", discoveryManager.proximityRadius / 1609.34))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .onChange(of: discoveryManager.proximityRadius) { _, _ in
                Task { await discoveryManager.refreshParties() }
            }
        }
        .padding()
        .background(Color(.systemBackground))
    }
    
    // MARK: - Search Bar
    private var searchBar: some View {
        VStack(spacing: 0) {
            HStack(spacing: 12) {
                // Search Icon
                Image(systemName: "magnifyingglass")
                    .foregroundColor(.secondary)
                    .font(.system(size: 16, weight: .medium))
                
                // Search Text Field
                TextField("Search topics, hosts, or keywords...", text: $searchText)
                    .textFieldStyle(PlainTextFieldStyle())
                    .font(.body)
                    .onTapGesture {
                        isSearching = true
                    }
                
                // Clear Button
                if !searchText.isEmpty {
                    Button(action: {
                        searchText = ""
                        isSearching = false
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                            .font(.system(size: 16))
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color(.systemGray6))
            .cornerRadius(12)
            .padding(.horizontal, 16)
            
            // Search Results
            if !searchText.isEmpty && !searchResults.isEmpty {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("Search Results")
                            .font(.headline)
                            .fontWeight(.bold)
                        Spacer()
                        Text("\(searchResults.count) found")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding(.horizontal, 16)
                    
                    LazyVStack(spacing: 12) {
                        ForEach(Array(searchResults.enumerated()), id: \.0) { (_, result) in
                            switch result {
                            case .party(let party):
                                PartyCard(
                                    party: party,
                                    currentLocation: locationManager.currentLocation,
                                    onJoin: {
                                        discoveryManager.quickJoinParty(party)
                                    },
                                    isNearbyParty: false
                                )
                                .onAppear { AnalyticsService.shared.logDiscoveryPartyImpression(tab: "search", partyId: party.id) }
                            case .topic(let topic):
                            TopicChatCard(
                                topic: topic,
                                onJoin: {
                                    AnalyticsService.shared.logDiscoveryQuickJoin(tab: "topics", partyId: topic.id)
                                    // TODO: Implement topic chat joining
                                }
                            )
                            .onAppear { AnalyticsService.shared.logDiscoveryPartyImpression(tab: "topics", partyId: topic.id) }
                            }
                        }
                    }
                    .padding(.horizontal, 16)
                }
                .padding(.top, 8)
            }
        }
    }
    
    
    // MARK: - Explore Tab
    private var exploreTabView: some View {
        VStack(spacing: 0) {
            if showingMap {
                mapView
            } else {
                exploreExploreContent
            }
        }
    }
    

    
    // MARK: - Explore Content (Trending, Influencers, DJs)
    private var exploreExploreContent: some View {
        ScrollView {
            LazyVStack(spacing: 32) {
                // Live DJs section
                liveDJsSection
                
                // Trending Parties Section
                exploreSection(
                    title: "Trending Parties",
                    icon: "flame.fill",
                    iconColor: .orange,
                    parties: trendingParties,
                    isExpanded: expandedTrending,
                    onToggleExpanded: { expandedTrending.toggle() },
                    onSeeAll: { showingTrendingPartiesAll = true }
                )
                
                // Influencer Parties Section
                exploreSection(
                    title: "Influencers",
                    icon: "checkmark.seal.fill",
                    iconColor: .blue,
                    parties: influencerParties,
                    isExpanded: expandedInfluencers,
                    onToggleExpanded: { expandedInfluencers.toggle() },
                    onSeeAll: { showingInfluencerPartiesAll = true }
                )
                
                // DJ Parties Section
                exploreSection(
                    title: "DJs",
                    icon: "radio.fill",
                    iconColor: .purple,
                    parties: djParties,
                    isExpanded: expandedDJs,
                    onToggleExpanded: { expandedDJs.toggle() },
                    onSeeAll: { showingDJPartiesAll = true }
                )
            }
            .padding(.horizontal, 0)
            .padding(.vertical, 16)
        }
        .refreshable { await refreshParties(); await loadLiveSessions() }
        .onAppear { Task { await loadLiveSessions() } }
        .sheet(isPresented: $showingTrendingPartiesAll) {
            ExploreSectionDetailView(
                title: "Trending Parties",
                parties: trendingParties,
                onJoin: { party in
                    AnalyticsService.shared.logDiscoveryQuickJoin(tab: "explore", partyId: party.id)
                    discoveryManager.quickJoinParty(party)
                }
            )
        }
        .sheet(isPresented: $showingInfluencerPartiesAll) {
            ExploreSectionDetailView(
                title: "Influencers",
                parties: influencerParties,
                onJoin: { party in
                    AnalyticsService.shared.logDiscoveryQuickJoin(tab: "explore", partyId: party.id)
                    discoveryManager.quickJoinParty(party)
                }
            )
        }
        .sheet(isPresented: $showingDJPartiesAll) {
            ExploreSectionDetailView(
                title: "DJs",
                parties: djParties,
                onJoin: { party in
                    AnalyticsService.shared.logDiscoveryQuickJoin(tab: "explore", partyId: party.id)
                    discoveryManager.quickJoinParty(party)
                }
            )
        }
    }
    
        // MARK: - Explore Section Helper
    private func exploreSection(
        title: String,
        icon: String,
        iconColor: Color,
        parties: [Party],
        isExpanded: Bool,
        onToggleExpanded: @escaping () -> Void,
        onSeeAll: @escaping () -> Void
    ) -> some View {
        VStack(alignment: .leading, spacing: 16) {
            // Section Header
                    HStack(spacing: 8) {
                Image(systemName: icon)
                    .foregroundColor(iconColor)
                            .font(.title2)
                Text(title)
                            .font(.headline)
                            .fontWeight(.bold)
                Spacer()
                if parties.count > 3 {
                    Button("See All") {
                        onSeeAll()
                    }
                    .font(.subheadline)
                    .foregroundColor(iconColor)
                }
            }
            .padding(.horizontal, 4)
            
            // Party Cards
            LazyVStack(spacing: 12) {
                let displayParties = isExpanded ? parties : Array(parties.prefix(3))
                ForEach(displayParties) { party in
                    PartyCard(
                        party: party,
                        currentLocation: locationManager.currentLocation,
                        onJoin: {
                            AnalyticsService.shared.logDiscoveryQuickJoin(tab: tabName(4), partyId: party.id)
                            discoveryManager.quickJoinParty(party)
                        },
                        isNearbyParty: false
                    )
                    .onAppear { AnalyticsService.shared.logDiscoveryPartyImpression(tab: tabName(4), partyId: party.id) }
                }
            }
            .padding(.horizontal, 16)
            
            // See More/Less Button at bottom
            if parties.count > 3 {
                Button(action: onToggleExpanded) {
                    HStack {
                        Text(isExpanded ? "See Less" : "See More")
                        .font(.subheadline)
                            .fontWeight(.medium)
                        Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                            .font(.caption)
                    }
                    .foregroundColor(iconColor)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(iconColor.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
    }

    private var influencerParties: [Party] {
        filteredExploreParties.filter { $0.isInfluencerParty && $0.isVerified }
    }
    
    private var trendingParties: [Party] {
        let base = filteredExploreParties.filter { !$0.isInfluencerParty && !isDJParty($0) }
        func score(_ p: Party) -> Double {
            let participants = Double(p.participants.count)
            let trend = p.trendingScore ?? 0
            let activity = p.voiceChatActive ? 0.3 : 0.0
            return trend + participants * 0.2 + activity
        }
        return base.sorted { score($0) > score($1) }.prefix(10).map { $0 }
    }
    
    private var djParties: [Party] {
        filteredExploreParties.filter { isDJParty($0) }
    }
    
    private func isDJParty(_ party: Party) -> Bool {
        let hostName = party.hostName.lowercased()
        let partyName = party.name.lowercased()
        return hostName.contains("dj") || partyName.contains("dj") || partyName.contains("mix") || partyName.contains("set")
    }
    
    // MARK: - Topics Computed Properties
    private var trendingTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.trending }
    }
    
    private var movieTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.movies }
    }
    
    private var sportsTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.sports }
    }
    
    private var gamingTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.gaming }
    }
    
    private var musicTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.music }
    }
    
    private var entertainmentTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.entertainment }
    }
    
    private var politicsTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.politics }
    }
    
    private var businessTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.business }
    }
    
    private var artsTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.arts }
    }
    
    private var foodTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.food }
    }
    
    private var lifestyleTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.lifestyle }
    }
    
    private var educationTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.education }
    }
    
    private var scienceTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.science }
    }
    
    private var worldNewsTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.worldNews }
    }
    
    private var healthTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.health }
    }
    
    private var automotiveTopics: [TopicChat] {
        topicChats.filter { $0.category == TopicCategory.automotive }
    }
    
    // MARK: - Search Result Types
    enum SearchResult: Identifiable {
        case party(Party)
        case topic(TopicChat)
        
        var id: String {
            switch self {
            case .party(let party): return "party_\(party.id)"
            case .topic(let topic): return "topic_\(topic.id)"
            }
        }
    }
    
    // MARK: - Search Results
    private var searchResults: [SearchResult] {
        if searchText.isEmpty {
            return []
        }
        
        var results: [SearchResult] = []
        
        // Search in parties
        let matchingParties = discoveryManager.currentParties.filter { party in
            party.name.localizedCaseInsensitiveContains(searchText) ||
            party.hostName.localizedCaseInsensitiveContains(searchText) ||
            (party.descriptionText?.localizedCaseInsensitiveContains(searchText) ?? false)
        }
        results.append(contentsOf: matchingParties.map { SearchResult.party($0) })
        
        // Search in topics
        let matchingTopics = topicChats.filter { topic in
            topic.title.localizedCaseInsensitiveContains(searchText) ||
            topic.description.localizedCaseInsensitiveContains(searchText) ||
            topic.hostName.localizedCaseInsensitiveContains(searchText) ||
            (topic.currentDiscussion?.localizedCaseInsensitiveContains(searchText) ?? false) ||
            topic.category.displayName.localizedCaseInsensitiveContains(searchText)
        }
        results.append(contentsOf: matchingTopics.map { SearchResult.topic($0) })
        
        return results
    }
    
    // MARK: - Search Filtered Topics (for backward compatibility)
    private var filteredTopics: [TopicChat] {
        if searchText.isEmpty {
            return []
        }
        return topicChats.filter { topic in
            topic.title.localizedCaseInsensitiveContains(searchText) ||
            topic.description.localizedCaseInsensitiveContains(searchText) ||
            topic.hostName.localizedCaseInsensitiveContains(searchText) ||
            (topic.currentDiscussion?.localizedCaseInsensitiveContains(searchText) ?? false) ||
            topic.category.displayName.localizedCaseInsensitiveContains(searchText)
        }
    }
    
    // MARK: - Topics Section Helper
    private func topicsSection(
        title: String,
        icon: String,
        iconColor: Color,
        topics: [TopicChat],
        isExpanded: Bool,
        onToggleExpanded: @escaping () -> Void,
        onSeeAll: @escaping () -> Void
    ) -> some View {
        VStack(alignment: .leading, spacing: 16) {
            // Section Header
            HStack(spacing: 8) {
                Image(systemName: icon)
                    .foregroundColor(iconColor)
                    .font(.title2)
                Text(title)
                    .font(.headline)
                    .fontWeight(.bold)
                Spacer()
                if topics.count > 3 {
                    Button("See All") {
                        onSeeAll()
                    }
                    .font(.subheadline)
                    .foregroundColor(iconColor)
                }
            }
            .padding(.horizontal, 4)
            
            // Topic Cards
            LazyVStack(spacing: 12) {
                let displayTopics = isExpanded ? topics : Array(topics.prefix(3))
                ForEach(displayTopics) { topic in
                    TopicChatCard(
                        topic: topic,
                        onJoin: {
                            AnalyticsService.shared.logDiscoveryQuickJoin(tab: "topics", partyId: topic.id)
                        }
                    )
                    .onTapGesture {
                        selectedTopic = topic
                    }
                    .onAppear { AnalyticsService.shared.logDiscoveryPartyImpression(tab: "topics", partyId: topic.id) }
                }
            }
            .padding(.horizontal, 16)
            
            // See More/Less Button at bottom
            if topics.count > 3 {
                Button(action: onToggleExpanded) {
                    HStack {
                        Text(isExpanded ? "See Less" : "See More")
                            .font(.subheadline)
                            .fontWeight(.medium)
                        Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                            .font(.caption)
                    }
                    .foregroundColor(iconColor)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(iconColor.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
                .padding(.horizontal, 16)
            }
        }
    }

    // MARK: - Topics Section Detail View
    private struct TopicsSectionDetailView: View {
        let title: String
        let topics: [TopicChat]
        let onSelect: (TopicChat) -> Void
        @Environment(\.dismiss) private var dismiss
        var body: some View {
            NavigationStack {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(topics) { t in
                            TopicChatCard(topic: t, onJoin: {})
                                .onTapGesture { onSelect(t) }
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 16)
                }
                .navigationTitle(title)
                .toolbar { ToolbarItem(placement: .navigationBarTrailing) { Button("Done") { dismiss() } } }
            }
        }
    }
    
    // MARK: - Live DJs Section (state declared at top); Firestore collection accessor
    private var liveSessionsCollection: CollectionReference { Firestore.firestore().collection("liveDJSessions") }

    private var liveDJsSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Image(systemName: "radio")
                    .foregroundColor(.red)
                    .font(.system(size: 20))
                Text("Live DJs")
                    .font(.headline)
                    .fontWeight(.bold)
                Spacer()
                if isLoadingLiveSessions { ProgressView().scaleEffect(0.9) }
                NavigationLink(destination: DJStreamView()) {
                    Text("Go Live")
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.red)
                        .cornerRadius(12)
                }
            }
            .padding(.horizontal, 4)
            if let err = liveSessionsError {
                HStack(spacing: 8) {
                    Image(systemName: "exclamationmark.triangle.fill").foregroundColor(.orange)
                    Text(err).font(.caption).foregroundColor(.secondary)
                    Button("Retry") { Task { await loadLiveSessions() } }
                        .font(.caption).foregroundColor(.purple)
                }
            } else if liveSessions.isEmpty && !isLoadingLiveSessions {
                HStack(spacing: 12) {
                    Image(systemName: "radio.fill").foregroundColor(.gray)
                    Text("No live sessions right now").foregroundColor(.secondary)
                }
                .font(.subheadline)
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(liveSessions.sorted(by: liveRailSort)) { session in
                            LiveDJCard(session: session, djStreamingManager: djStreamingManager)
                                .accessibilityLabel("Live DJ: \(session.title) by \(session.djUsername)")
                        }
                        Button(action: { showAllLiveDJs = true }) {
                            Label("See All", systemImage: "chevron.right")
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(Color(.systemGray6))
                .cornerRadius(8)
            }
        }
                }
            }
        }
        .sheet(isPresented: $showAllLiveDJs) { LiveDJSessionsListView() }
    }

    // MARK: - Live DJ Fetching
    private func loadLiveSessions() async {
        await MainActor.run { isLoadingLiveSessions = true }
        let db = Firestore.firestore()
        do {
            let snap = try await db.collection("liveDJSessions")
                .whereField("status", isEqualTo: DJStreamStatus.live.rawValue)
                .limit(to: 20)
                .getDocuments()
            let sessions = snap.documents.compactMap { try? $0.data(as: LiveDJSession.self) }
            await MainActor.run {
                self.liveSessions = sessions
                self.isLoadingLiveSessions = false
            }
        } catch {
            await MainActor.run { self.isLoadingLiveSessions = false }
        }
    }

    private func startLiveSessionsListener() {
        liveSessionsListener?.remove()
        liveSessionsListener = liveSessionsCollection
            .whereField("status", isEqualTo: DJStreamStatus.live.rawValue)
            .addSnapshotListener { snapshot, _ in
                let sessions = snapshot?.documents.compactMap { try? $0.data(as: LiveDJSession.self) } ?? []
                Task { @MainActor in self.liveSessions = sessions }
            }
    }

    private func stopLiveSessionsListener() {
        liveSessionsListener?.remove()
        liveSessionsListener = nil
    }

    private func liveRailSort(_ a: LiveDJSession, _ b: LiveDJSession) -> Bool {
        // Followed DJs first if available, then by listenerCount desc
        // This rail lacks following context; default to popular
        if a.listenerCount != b.listenerCount { return a.listenerCount > b.listenerCount }
        return (a.startedAt ?? a.createdAt) > (b.startedAt ?? b.createdAt)
    }
    
    // MARK: - Topics Loading
    private func loadEnabledCategories() {
        // Load saved enabled categories from UserDefaults
        if let savedCategories = UserDefaults.standard.array(forKey: "enabledTopicCategories") as? [String] {
            let categories = savedCategories.compactMap { TopicCategory(rawValue: $0) }
            enabledCategories = Set(categories)
        } else {
            // Use default categories if none saved
            enabledCategories = Set(TopicCategory.defaultCategories)
        }
    }
    
    private func loadTopicChats() async {
        isLoadingTopics = true
        
        // For now, load mock data
        await MainActor.run {
            self.topicChats = createMockTopicChats()
            self.isLoadingTopics = false
        }
    }
    
    private func createMockTopicChats() -> [TopicChat] {
        var mockTopics: [TopicChat] = []
        
        // Trending Topics
        var t0 = TopicChat(title: "Latest Tech News Discussion", description: "Discussing the newest developments in AI and technology", category: TopicCategory.trending, hostId: "tech_host", hostName: "Alex")
        t0.participants = Array(0..<8).map { i in TopicParticipant(id: "user\(i)", name: "User\(i)", isHost: false) }
        t0.participants.insert(TopicParticipant(id: "tech_host", name: "Alex", isHost: true), at: 0)
        t0.currentDiscussion = "What do you think about the latest AI developments?"
        t0.trendingScore = 0.9
        t0.voiceChatEnabled = true
        t0.voiceChatActive = true
        t0.speakers = ["tech_host"]
        t0.listeners = Array(0..<8).map { "user\($0)" }
        mockTopics.append(t0)
        
        var t1 = TopicChat(title: "Election 2024 Discussion", description: "Civil discussion about current political events", category: TopicCategory.trending, hostId: "politics_host", hostName: "Sarah")
        t1.participants = Array(0..<12).map { i in TopicParticipant(id: "voter\(i)", name: "Voter\(i)", isHost: false) }
        t1.participants.insert(TopicParticipant(id: "politics_host", name: "Sarah", isHost: true), at: 0)
        t1.currentDiscussion = "What issues matter most to you this election?"
        t1.trendingScore = 0.95
        t1.voiceChatEnabled = true
        t1.voiceChatActive = true
        t1.speakers = ["politics_host", "voter1", "voter2"]
        t1.listeners = Array(2..<12).map { "voter\($0)" }
        mockTopics.append(t1)
        
        var t2 = TopicChat(title: "Climate Change Solutions", description: "Discussing practical solutions for environmental challenges", category: TopicCategory.trending, hostId: "climate_host", hostName: "Emma")
        t2.participants = Array(0..<6).map { i in TopicParticipant(id: "eco\(i)", name: "Eco\(i)", isHost: false) }
        t2.participants.insert(TopicParticipant(id: "climate_host", name: "Emma", isHost: true), at: 0)
        t2.currentDiscussion = "What can individuals do to make a difference?"
        t2.trendingScore = 0.8
        mockTopics.append(t2)
        
        var t3 = TopicChat(title: "Space Exploration News", description: "Latest updates on Mars missions and space technology", category: TopicCategory.trending, hostId: "space_host", hostName: "Neil")
        t3.participants = Array(0..<9).map { i in TopicParticipant(id: "space\(i)", name: "Space\(i)", isHost: false) }
        t3.participants.insert(TopicParticipant(id: "space_host", name: "Neil", isHost: true), at: 0)
        t3.currentDiscussion = "What's the next big space mission?"
        t3.trendingScore = 0.75
        mockTopics.append(t3)
        
        var t4 = TopicChat(title: "Cryptocurrency Discussion", description: "Discussing the future of digital currencies", category: TopicCategory.trending, hostId: "crypto_host", hostName: "Satoshi")
        t4.participants = Array(0..<11).map { i in TopicParticipant(id: "crypto\(i)", name: "Crypto\(i)", isHost: false) }
        t4.participants.insert(TopicParticipant(id: "crypto_host", name: "Satoshi", isHost: true), at: 0)
        t4.currentDiscussion = "Which crypto will be the next big thing?"
        t4.trendingScore = 0.85
        mockTopics.append(t4)
        
        // Movies & TV
        var m0 = TopicChat(title: "Marvel Phase 5 Discussion", description: "Discussing the latest Marvel movies and shows", category: TopicCategory.movies, hostId: "marvel_host", hostName: "Mike")
        m0.participants = Array(0..<10).map { i in TopicParticipant(id: "fan\(i)", name: "Fan\(i)", isHost: false) }
        m0.participants.insert(TopicParticipant(id: "marvel_host", name: "Mike", isHost: true), at: 0)
        m0.currentDiscussion = "What did you think of the latest Marvel release?"
        m0.voiceChatEnabled = true
        m0.voiceChatActive = true
        m0.speakers = ["marvel_host", "fan1"]
        m0.listeners = Array(2..<10).map { "fan\($0)" }
        mockTopics.append(m0)
        
        var m1 = TopicChat(title: "Netflix Recommendations", description: "Sharing the best shows and movies on Netflix", category: TopicCategory.movies, hostId: "netflix_host", hostName: "Lisa")
        m1.participants = Array(0..<7).map { i in TopicParticipant(id: "viewer\(i)", name: "Viewer\(i)", isHost: false) }
        m1.participants.insert(TopicParticipant(id: "netflix_host", name: "Lisa", isHost: true), at: 0)
        m1.currentDiscussion = "What's the best show you've watched recently?"
        mockTopics.append(m1)
        
        var m2 = TopicChat(title: "Anime Discussion", description: "Talking about the latest anime releases", category: TopicCategory.movies, hostId: "anime_host", hostName: "Ken")
        m2.participants = Array(0..<7).map { i in TopicParticipant(id: "otaku\(i)", name: "Otaku\(i)", isHost: false) }
        m2.participants.insert(TopicParticipant(id: "anime_host", name: "Ken", isHost: true), at: 0)
        m2.currentDiscussion = "Which anime are you watching this season?"
        mockTopics.append(m2)
        
        var m3 = TopicChat(title: "Classic Movies Club", description: "Discussing timeless films and cinema history", category: TopicCategory.movies, hostId: "classic_host", hostName: "Martin")
        m3.participants = Array(0..<8).map { i in TopicParticipant(id: "classic\(i)", name: "Classic\(i)", isHost: false) }
        m3.participants.insert(TopicParticipant(id: "classic_host", name: "Martin", isHost: true), at: 0)
        m3.currentDiscussion = "What's your favorite classic film?"
        mockTopics.append(m3)
        
        var m4 = TopicChat(title: "Documentary Reviews", description: "Sharing thoughts on educational and informative documentaries", category: TopicCategory.movies, hostId: "doc_host", hostName: "Diana")
        m4.participants = Array(0..<6).map { i in TopicParticipant(id: "doc\(i)", name: "Doc\(i)", isHost: false) }
        m4.participants.insert(TopicParticipant(id: "doc_host", name: "Diana", isHost: true), at: 0)
        m4.currentDiscussion = "Which documentary changed your perspective?"
        mockTopics.append(m4)
        
        // Sports
        var s0 = TopicChat(title: "NBA Playoffs Discussion", description: "Discussing the current NBA playoff race", category: TopicCategory.sports, hostId: "nba_host", hostName: "Chris")
        s0.participants = Array(0..<15).map { i in TopicParticipant(id: "basketball\(i)", name: "Basketball\(i)", isHost: false) }
        s0.participants.insert(TopicParticipant(id: "nba_host", name: "Chris", isHost: true), at: 0)
        s0.currentDiscussion = "Who do you think will win the championship?"
        s0.voiceChatEnabled = true
        s0.voiceChatActive = true
        s0.speakers = ["nba_host", "basketball1", "basketball2"]
        s0.listeners = Array(3..<15).map { "basketball\($0)" }
        mockTopics.append(s0)
        
        var s1 = TopicChat(title: "Fantasy Football Tips", description: "Sharing fantasy football strategies and advice", category: TopicCategory.sports, hostId: "ff_host", hostName: "David")
        s1.participants = Array(0..<8).map { i in TopicParticipant(id: "fantasy\(i)", name: "Fantasy\(i)", isHost: false) }
        s1.participants.insert(TopicParticipant(id: "ff_host", name: "David", isHost: true), at: 0)
        s1.currentDiscussion = "Who should I start this week?"
        mockTopics.append(s1)
        
        var s2 = TopicChat(title: "Soccer World Cup Discussion", description: "Discussing international soccer and World Cup predictions", category: TopicCategory.sports, hostId: "soccer_host", hostName: "Maria")
        s2.participants = Array(0..<8).map { i in TopicParticipant(id: "football\(i)", name: "Football\(i)", isHost: false) }
        s2.participants.insert(TopicParticipant(id: "soccer_host", name: "Maria", isHost: true), at: 0)
        s2.currentDiscussion = "Which team will win the next World Cup?"
        mockTopics.append(s2)
        
        var s3 = TopicChat(title: "Tennis Grand Slams", description: "Discussing major tennis tournaments and players", category: TopicCategory.sports, hostId: "tennis_host", hostName: "Roger")
        s3.participants = Array(0..<7).map { i in TopicParticipant(id: "tennis\(i)", name: "Tennis\(i)", isHost: false) }
        s3.participants.insert(TopicParticipant(id: "tennis_host", name: "Roger", isHost: true), at: 0)
        s3.currentDiscussion = "Who will win the next Grand Slam?"
        mockTopics.append(s3)
        
        var s4 = TopicChat(title: "Olympics Discussion", description: "Talking about Olympic sports and athletes", category: TopicCategory.sports, hostId: "olympics_host", hostName: "Usain")
        s4.participants = Array(0..<10).map { i in TopicParticipant(id: "olympian\(i)", name: "Olympian\(i)", isHost: false) }
        s4.participants.insert(TopicParticipant(id: "olympics_host", name: "Usain", isHost: true), at: 0)
        s4.currentDiscussion = "Which Olympic sport is most exciting?"
        mockTopics.append(s4)
        
        // Gaming
        var g0 = TopicChat(title: "GTA 6 Discussion", description: "Discussing the upcoming GTA 6 release", category: TopicCategory.gaming, hostId: "gta_host", hostName: "Jake")
        g0.participants = Array(0..<20).map { i in TopicParticipant(id: "gamer\(i)", name: "Gamer\(i)", isHost: false) }
        g0.participants.insert(TopicParticipant(id: "gta_host", name: "Jake", isHost: true), at: 0)
        g0.currentDiscussion = "What features are you most excited about?"
        g0.voiceChatEnabled = true
        g0.voiceChatActive = true
        g0.speakers = ["gta_host", "gamer1", "gamer2", "gamer3"]
        g0.listeners = Array(4..<20).map { "gamer\($0)" }
        mockTopics.append(g0)
        
        var g1 = TopicChat(title: "League of Legends Tips", description: "Sharing LoL strategies and gameplay tips", category: TopicCategory.gaming, hostId: "lol_host", hostName: "Anna")
        g1.participants = Array(0..<6).map { i in TopicParticipant(id: "summoner\(i)", name: "Summoner\(i)", isHost: false) }
        g1.participants.insert(TopicParticipant(id: "lol_host", name: "Anna", isHost: true), at: 0)
        g1.currentDiscussion = "What's the best way to improve at LoL?"
        mockTopics.append(g1)
        
        var g2 = TopicChat(title: "Indie Game Recommendations", description: "Discovering and discussing indie games", category: TopicCategory.gaming, hostId: "indie_host", hostName: "Tom")
        g2.participants = Array(0..<5).map { i in TopicParticipant(id: "indie\(i)", name: "Indie\(i)", isHost: false) }
        g2.participants.insert(TopicParticipant(id: "indie_host", name: "Tom", isHost: true), at: 0)
        g2.currentDiscussion = "What indie games have you played recently?"
        mockTopics.append(g2)
        
        var g3 = TopicChat(title: "Mobile Gaming Discussion", description: "Talking about mobile games and trends", category: TopicCategory.gaming, hostId: "mobile_host", hostName: "Zoe")
        g3.participants = Array(0..<9).map { i in TopicParticipant(id: "mobile\(i)", name: "Mobile\(i)", isHost: false) }
        g3.participants.insert(TopicParticipant(id: "mobile_host", name: "Zoe", isHost: true), at: 0)
        g3.currentDiscussion = "What's the best mobile game right now?"
        mockTopics.append(g3)
        
        var g4 = TopicChat(title: "Esports Discussion", description: "Discussing competitive gaming and tournaments", category: TopicCategory.gaming, hostId: "esports_host", hostName: "Faker")
        g4.participants = Array(0..<12).map { i in TopicParticipant(id: "esports\(i)", name: "Esports\(i)", isHost: false) }
        g4.participants.insert(TopicParticipant(id: "esports_host", name: "Faker", isHost: true), at: 0)
        g4.currentDiscussion = "Which esports team is the best?"
        mockTopics.append(g4)
        
        // Music Topics
        var mu0 = TopicChat(title: "New Album Reviews", description: "Discussing the latest music releases", category: TopicCategory.music, hostId: "music_host", hostName: "DJ")
        mu0.participants = Array(0..<8).map { i in TopicParticipant(id: "music\(i)", name: "Music\(i)", isHost: false) }
        mu0.participants.insert(TopicParticipant(id: "music_host", name: "DJ", isHost: true), at: 0)
        mu0.currentDiscussion = "What's your favorite album this year?"
        mockTopics.append(mu0)
        
        // Entertainment Topics
        var e0 = TopicChat(title: "Celebrity News", description: "Latest updates from the entertainment world", category: TopicCategory.entertainment, hostId: "entertainment_host", hostName: "Gossip")
        e0.participants = Array(0..<6).map { i in TopicParticipant(id: "entertainment\(i)", name: "Entertainment\(i)", isHost: false) }
        e0.participants.insert(TopicParticipant(id: "entertainment_host", name: "Gossip", isHost: true), at: 0)
        e0.currentDiscussion = "Which celebrity news surprised you most?"
        mockTopics.append(e0)
        
        // Politics Topics
        var p0 = TopicChat(title: "Current Events Discussion", description: "Civil discussion about political developments", category: TopicCategory.politics, hostId: "politics_host2", hostName: "Policy")
        p0.participants = Array(0..<10).map { i in TopicParticipant(id: "politics\(i)", name: "Politics\(i)", isHost: false) }
        p0.participants.insert(TopicParticipant(id: "politics_host2", name: "Policy", isHost: true), at: 0)
        p0.currentDiscussion = "What policy changes would you like to see?"
        mockTopics.append(p0)
        
        // Business Topics
        var b0 = TopicChat(title: "Startup Discussion", description: "Talking about entrepreneurship and business", category: TopicCategory.business, hostId: "business_host", hostName: "Entrepreneur")
        b0.participants = Array(0..<7).map { i in TopicParticipant(id: "business\(i)", name: "Business\(i)", isHost: false) }
        b0.participants.insert(TopicParticipant(id: "business_host", name: "Entrepreneur", isHost: true), at: 0)
        b0.currentDiscussion = "What's the next big business opportunity?"
        mockTopics.append(b0)
        
        // Arts & Culture Topics
        var a0 = TopicChat(title: "Art Gallery Reviews", description: "Discussing contemporary art and exhibitions", category: TopicCategory.arts, hostId: "arts_host", hostName: "Curator")
        a0.participants = Array(0..<5).map { i in TopicParticipant(id: "arts\(i)", name: "Arts\(i)", isHost: false) }
        a0.participants.insert(TopicParticipant(id: "arts_host", name: "Curator", isHost: true), at: 0)
        a0.currentDiscussion = "Which art movement inspires you most?"
        mockTopics.append(a0)
        
        // Food & Dining Topics
        var f0 = TopicChat(title: "Restaurant Recommendations", description: "Sharing the best dining experiences", category: TopicCategory.food, hostId: "food_host", hostName: "Chef")
        f0.participants = Array(0..<9).map { i in TopicParticipant(id: "food\(i)", name: "Food\(i)", isHost: false) }
        f0.participants.insert(TopicParticipant(id: "food_host", name: "Chef", isHost: true), at: 0)
        f0.currentDiscussion = "What's the best restaurant you've tried recently?"
        mockTopics.append(f0)
        
        // Lifestyle Topics
        var l0 = TopicChat(title: "Fashion Trends", description: "Discussing current fashion and style", category: TopicCategory.lifestyle, hostId: "lifestyle_host", hostName: "Stylist")
        l0.participants = Array(0..<8).map { i in TopicParticipant(id: "lifestyle\(i)", name: "Lifestyle\(i)", isHost: false) }
        l0.participants.insert(TopicParticipant(id: "lifestyle_host", name: "Stylist", isHost: true), at: 0)
        l0.currentDiscussion = "What fashion trend are you loving right now?"
        mockTopics.append(l0)
        
        // Education Topics
        var ed0 = TopicChat(title: "Learning Resources", description: "Sharing educational content and courses", category: TopicCategory.education, hostId: "education_host", hostName: "Professor")
        ed0.participants = Array(0..<6).map { i in TopicParticipant(id: "education\(i)", name: "Education\(i)", isHost: false) }
        ed0.participants.insert(TopicParticipant(id: "education_host", name: "Professor", isHost: true), at: 0)
        ed0.currentDiscussion = "What skill are you currently learning?"
        mockTopics.append(ed0)
        
        // Science & Tech Topics
        var sc0 = TopicChat(title: "Scientific Discoveries", description: "Discussing latest scientific breakthroughs", category: TopicCategory.science, hostId: "science_host", hostName: "Scientist")
        sc0.participants = Array(0..<7).map { i in TopicParticipant(id: "science\(i)", name: "Science\(i)", isHost: false) }
        sc0.participants.insert(TopicParticipant(id: "science_host", name: "Scientist", isHost: true), at: 0)
        sc0.currentDiscussion = "Which scientific discovery excites you most?"
        mockTopics.append(sc0)
        
        // World News Topics
        var w0 = TopicChat(title: "Global Events", description: "Discussing international news and events", category: TopicCategory.worldNews, hostId: "world_host", hostName: "Reporter")
        w0.participants = Array(0..<8).map { i in TopicParticipant(id: "world\(i)", name: "World\(i)", isHost: false) }
        w0.participants.insert(TopicParticipant(id: "world_host", name: "Reporter", isHost: true), at: 0)
        w0.currentDiscussion = "What global event should we be paying attention to?"
        mockTopics.append(w0)
        
        // Health & Fitness Topics
        var h0 = TopicChat(title: "Wellness Tips", description: "Sharing health and fitness advice", category: TopicCategory.health, hostId: "health_host", hostName: "Trainer")
        h0.participants = Array(0..<9).map { i in TopicParticipant(id: "health\(i)", name: "Health\(i)", isHost: false) }
        h0.participants.insert(TopicParticipant(id: "health_host", name: "Trainer", isHost: true), at: 0)
        h0.currentDiscussion = "What's your favorite workout routine?"
        mockTopics.append(h0)
        
        // Automotive Topics
        var au0 = TopicChat(title: "Car Reviews", description: "Discussing the latest vehicles and automotive news", category: TopicCategory.automotive, hostId: "auto_host", hostName: "Mechanic")
        au0.participants = Array(0..<7).map { i in TopicParticipant(id: "auto\(i)", name: "Auto\(i)", isHost: false) }
        au0.participants.insert(TopicParticipant(id: "auto_host", name: "Mechanic", isHost: true), at: 0)
        au0.currentDiscussion = "What's your dream car?"
        mockTopics.append(au0)
        
        return mockTopics
    }
    
    // MARK: - Enhanced Map View
    private var mapView: some View {
        Map(position: $cameraPosition) {
            ForEach(discoveryManager.currentParties) { party in
                let coord = CLLocationCoordinate2D(latitude: party.latitude ?? 0, longitude: party.longitude ?? 0)
                Annotation(party.name, coordinate: coord) {
                    PartyMapAnnotation(party: party)
                        .onTapGesture {
                            selectedParty = party
                            showingPartyDetail = true
                        }
                }
            }
        }
        .overlay(alignment: .topTrailing) {
            // Map Controls
            VStack(spacing: 12) {
                // Location Button
                Button(action: centerOnUserLocation) {
                    Image(systemName: "location.fill")
                        .font(.title2)
                        .foregroundColor(.white)
                        .frame(width: 44, height: 44)
                        .background(Color.blue)
                        .clipShape(Circle())
                        .shadow(radius: 4)
                }
                
                // Filter Button
                Button(action: { showingMapFilters = true }) {
                    Image(systemName: "line.3.horizontal.decrease.circle.fill")
                        .font(.title2)
                        .foregroundColor(.white)
                        .frame(width: 44, height: 44)
                        .background(Color.purple)
                        .clipShape(Circle())
                        .shadow(radius: 4)
                }
            }
            .padding(.trailing, 16)
            .padding(.top, 100)
        }
        .overlay(alignment: .bottom) {
            // Map Legend
            if !discoveryManager.currentParties.isEmpty {
                mapLegendView
            }
        }
        .fullScreenCover(isPresented: $showingPartyDetail) {
            if let party = selectedParty {
                PartyPreviewView(
                    party: party,
                    currentLocation: locationManager.currentLocation,
                    onJoin: {
                        discoveryManager.quickJoinParty(party)
                    }
                )
            }
        }
        .sheet(isPresented: $showingMapFilters) {
            NavigationView {
                MapFiltersView(
                    selectedFilter: $discoveryManager.mapFilter,
                    onApply: applyMapFilters
                )
            }
        }
        .onAppear {
            // Keep camera in sync with region on appear
            updateMapRegion()
            cameraPosition = .region(region)
        }
    }
    
    // MARK: - Party List View
    private func partyListView(parties: [Party]) -> some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                    ForEach(parties) { party in
                    PartyCard(party: party, currentLocation: locationManager.currentLocation, onJoin: {
                                    discoveryManager.quickJoinParty(party)
                                }, isNearbyParty: false)
                            }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 16)
        }
    }
    
    // MARK: - Nearby Party List View (with yellow join buttons)
    private func nearbyPartyListView(parties: [Party]) -> some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                #if DEBUG
                if UserDefaults.standard.bool(forKey: "discovery.mockData") {
                    Text("Mock Data Enabled - Showing \(parties.count) nearby parties")
                        .font(.caption)
                        .foregroundColor(.purple)
                        .padding(.horizontal, 16)
                }
                #endif
                
                ForEach(parties) { party in
                    PartyCard(
                        party: party,
                        currentLocation: locationManager.currentLocation,
                        onJoin: {
                            discoveryManager.quickJoinParty(party)
                        },
                        isNearbyParty: true
                    )
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 16)
        }
    }
    
    // MARK: - Missing View Components
    private var mapLegendView: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Map Legend")
                .font(.headline)
                .foregroundColor(.primary)
            
            HStack(spacing: 12) {
                Circle()
                    .fill(Color.purple)
                    .frame(width: 10, height: 10)
                    .shadow(radius: 2)
                Text("Your Location")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            HStack(spacing: 12) {
                Circle()
                    .fill(Color.blue)
                    .frame(width: 10, height: 10)
                    .shadow(radius: 2)
                Text("Location Shared")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            HStack(spacing: 12) {
                Circle()
                    .fill(Color.green)
                    .frame(width: 10, height: 10)
                    .shadow(radius: 2)
                Text("Voice Chat Active")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            HStack(spacing: 12) {
                Circle()
                    .fill(Color.orange)
                    .frame(width: 10, height: 10)
                    .shadow(radius: 2)
                Text("Trending Party")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            HStack(spacing: 12) {
                Circle()
                    .fill(Color.red)
                    .frame(width: 10, height: 10)
                    .shadow(radius: 2)
                Text("Friends Only Party")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
    }
    
    private func centerOnUserLocation() {
        guard let location = locationManager.currentLocation else { return }
        region = MKCoordinateRegion(
            center: location.coordinate,
            span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)
        )
    }
    
    private func updateMapRegion() {
        guard let location = locationManager.currentLocation else { return }
        region = MKCoordinateRegion(
            center: location.coordinate,
            span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)
        )
    }
    
    // MARK: - Loading View
    private var loadingView: some View {
        VStack(spacing: 16) {
            ProgressView()
                .scaleEffect(1.2)
            Text("Discovering parties...")
                .font(.body)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding(.horizontal, 0)
    }
    
    // MARK: - Empty State View
    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Image(systemName: "music.note.list")
                .font(.system(size: 40))
                .foregroundColor(.gray)
            
            Text("No Parties Found")
                .font(.headline)
                .foregroundColor(.primary)
            
            Text(getEmptyStateMessage())
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
            
            // Context-aware CTAs
            Group {
                switch selectedTab {
                case 0: // Following
                    Button("Find People to Follow") { showUserSearch = true }
                        .buttonStyle(.borderedProminent)
                        .tint(.purple)
                case 1: // Friends
                    Button("Invite Friends") { presentInviteShare() }
                        .buttonStyle(.borderedProminent)
                        .tint(.purple)
                case 2: // Nearby
                    if !discoveryManager.isProximityDiscoveryEnabled {
                        Button("Enable Proximity Discovery") {
                            discoveryManager.updateProximitySettings(enabled: true)
                        }
                        .buttonStyle(.borderedProminent)
                        .tint(.purple)
                    } else {
                        Button("Expand Radius") {
                            discoveryManager.proximityRadius = min(discoveryManager.proximityRadius * 2, 8046.72)
                            Task { await discoveryManager.refreshParties() }
                        }
                        .buttonStyle(.bordered)
                    }
                default:
                    EmptyView()
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding()
    }
    
    // MARK: - Helper Functions
    func formatFollowerCount(_ count: Int) -> String {
        if count >= 1_000_000 {
            return String(format: "%.1fM", Double(count) / 1_000_000)
        } else if count >= 1_000 {
            return String(format: "%.1fK", Double(count) / 1_000)
        } else {
            return "\(count)"
        }
    }
    
    // MARK: - Empty State Messages
    private func getEmptyStateMessage() -> String {
        switch selectedTab {
        case 0:
            return "No parties from people you follow yet. Follow some influencers to see their parties here!"
        case 1:
            return "No friends are hosting parties right now. Invite friends to join and start parties!"
        case 2:
            if !discoveryManager.isAgeVerified {
                return "Age verification required to access proximity features."
            } else if !discoveryManager.isProximityDiscoveryEnabled {
                return "Enable proximity discovery to see nearby parties."
            } else if discoveryManager.locationValidationFailed {
                return "Location validation failed. Please check your location settings."
            } else {
            return "No parties nearby. Try expanding your search radius or check back later!"
            }
        case 3:
            return "No trending parties available. Check back later for popular parties!"
        default:
            return "No parties are currently available in this category"
        }
    }
    
    // MARK: - Tab Header View
    private func tabHeaderView(title: String, icon: String, count: Int, description: String) -> some View {
        VStack(spacing: 16) {
            HStack {
                VStack(alignment: .leading, spacing: 6) {
                    HStack(spacing: 10) {
                        Image(systemName: icon)
                            .foregroundColor(.purple)
                            .font(.title2)
                        
                        Text(title)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.primary)
                    }
                    
                    Text(description)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                // Quick Preview Stats
                VStack(alignment: .trailing, spacing: 6) {
                    Text("\(count)")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.purple)
                    
                    Text("parties")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(.horizontal, 0)
        .padding(.vertical, 20)
        .background(Color(.systemBackground))
    }
    
    // MARK: - Page Indicator
    private var pageIndicatorOverlay: some View {
        GeometryReader { proxy in
            let bottomInset = proxy.safeAreaInsets.bottom
            HStack(spacing: 8) {
                ForEach(0..<5, id: \.self) { idx in
                    Circle()
                        .fill(selectedTab == idx ? Color.primary : Color.secondary.opacity(0.4))
                        .frame(width: 6, height: 6)
                }
            }
            .padding(.bottom, max(0, bottomInset + 4))
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom)
        }
    }
    
    // MARK: - Refresh Parties
    private func refreshParties() async {
        await discoveryManager.refreshParties()
    }
    
    // MARK: - Helper to map tab index to name
    private func tabName(_ idx: Int) -> String {
        switch idx {
        case 0: return "following"
        case 1: return "friends"
        case 2: return "nearby"
        case 3: return "explore"
        default: return "unknown"
        }
    }
    
    // MARK: - Missing Helper Functions
    private func setupLocationServices() async {
        locationManager.requestLocationPermission()
        
        // Start discovery after location services are set up
        await discoveryManager.startDiscovery(locationManager: locationManager)
    }
    
    private func applyMapFilters(filter: MapFilter) {
        discoveryManager.mapFilter = filter
        // Re-apply filters to currentParties
        // Note: currentParties is a computed property, so we can't assign to it
        // The filtering will be handled by the mapFilter property
    }
    
    private func presentInviteShare() {
        // Fallback: copy app join instructions (no specific party context here)
        let text = "Invite friends to Bumpin! Share your party code or start a new party from the Home tab."
        let av = UIActivityViewController(activityItems: [text], applicationActivities: nil)
        if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let root = scene.windows.first?.rootViewController {
            root.present(av, animated: true)
        }
    }
    
    private func formatDistance(_ distance: CLLocationDistance) -> String {
        if distance < 1000 {
            return "\(Int(distance))m"
        } else {
            return String(format: "%.1fkm", distance / 1000)
        }
    }
}

// MARK: - Enhanced Party Card used in friends/following/nearby lists
struct PartyCard: View {
    let party: Party
    let currentLocation: CLLocation?
    let onJoin: () -> Void
    let isNearbyParty: Bool
    @State private var showingPreview = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header with party name and timer
            HStack {
                Text(party.name)
                    .font(.headline)
                    .fontWeight(.bold)
                
                Spacer()
                
                // Timer showing how long party has been running
                Text("Started \(RelativeTimeFormatter.shared.string(for: party.createdAt))")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
                        // Host info
            HStack(spacing: 12) {
                // Host profile picture
                Circle()
                    .fill(Color.purple.opacity(0.3))
                    .frame(width: 24, height: 24)
                    .overlay(
                        Image(systemName: "person.fill")
                            .foregroundColor(.purple)
                            .font(.system(size: 12))
                    )
                    .onTapGesture {
                        NotificationCenter.default.post(
                            name: NSNotification.Name("OpenUserProfile"),
                            object: party.hostId
                        )
                    }
                
                VStack(alignment: .leading, spacing: 4) {
                    HStack(spacing: 0) {
                        Text("by ")
                            .foregroundColor(.secondary)
                        Text(party.hostName)
                            .foregroundColor(.purple)
                            .fontWeight(.medium)
                    }
                    .onTapGesture {
                        NotificationCenter.default.post(
                            name: NSNotification.Name("OpenUserProfile"),
                            object: party.hostId
                        )
                    }
                    
                    // Member count
                    HStack(spacing: 4) {
                        Image(systemName: "person.2.fill")
                            .foregroundColor(.secondary)
                            .font(.caption)
                        Text("\(party.participants.count) members")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
            }
            
            // Join button centered
            Button(action: onJoin) {
                Text("Join")
                    .font(.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(party.isFriendsParty ? Color.green : (isNearbyParty ? Color.yellow : Color.blue))
                    .cornerRadius(8)
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
        .onTapGesture {
            showingPreview = true
        }
        .sheet(isPresented: $showingPreview) {
            PartyPreviewView(
                party: party,
                currentLocation: currentLocation,
                onJoin: {
                    showingPreview = false
                    onJoin()
                }
            )
        }
    }
    
    private func formatDistance(_ distance: CLLocationDistance) -> String {
        if distance < 1000 {
            return "\(Int(distance))m"
        } else {
            return String(format: "%.1fkm", distance / 1000)
        }
    }
}

// MARK: - Party Map Annotation
struct PartyMapAnnotation: View {
    let party: Party
    
    var body: some View {
        VStack(spacing: 4) {
            ZStack {
                Circle()
                    .fill(Color.purple)
                    .frame(width: 40, height: 40)
                
                Image(systemName: "music.note")
                    .foregroundColor(.white)
                    .font(.system(size: 16))
            }
            
            Text(party.name)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.white)
                .padding(.horizontal, 6)
                .padding(.vertical, 2)
                .background(Color.black.opacity(0.7))
                .cornerRadius(4)
        }
    }
}

// End file

// MARK: - Quick Preview Card
struct QuickPreviewCard: View {
    let party: Party
    let currentLocation: CLLocation?
    let formatFollowerCount: (Int) -> String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Party Icon and Name
            HStack(spacing: 8) {
                ZStack {
                    Circle()
                        .fill(Color.purple.opacity(0.2))
                        .frame(width: 40, height: 40)
                    
                    Image(systemName: "music.note")
                        .foregroundColor(.purple)
                        .font(.system(size: 16))
                }
                
                VStack(alignment: .leading, spacing: 2) {
                    HStack(spacing: 2) {
                        Text(party.name)
                            .font(.subheadline)
                            .fontWeight(.semibold)
                            .lineLimit(1)
                        
                        // Verified badge for influencers
                        if party.isInfluencerParty && party.isVerified {
                            Image(systemName: "checkmark.seal.fill")
                                .foregroundColor(.blue)
                                .font(.caption2)
                        }
                    }
                    
                    HStack(spacing: 2) {
                        Text(party.hostName)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .lineLimit(1)
                        
                        // Follower count for influencers
                        if party.isInfluencerParty, let followerCount = party.followerCount {
                            Text("â€¢ \(formatFollowerCount(followerCount))")
                                .font(.caption2)
                                .foregroundColor(.purple)
                        }
                        
                        // Friends-only indicator
                        if party.isFriendsParty && party.friendsOnly {
                            Text("â€¢ Friends Only")
                                .font(.caption2)
                                .foregroundColor(.green)
                        }
                    }
                }
                
                Spacer()
                
                HStack(spacing: 2) {
                    // Voice chat indicator
                    if party.voiceChatActive {
                        Image(systemName: "mic.fill")
                            .foregroundColor(.purple)
                            .font(.caption)
                    }
                    
                    // Location sharing indicator for friends
                    if party.isFriendsParty && party.locationSharingEnabled {
                        Image(systemName: "location.fill")
                            .foregroundColor(.blue)
                            .font(.caption)
                    }
                }
            }
            
            // Quick Stats
            HStack(spacing: 12) {
                // Member count
                HStack(spacing: 2) {
                    Image(systemName: "person.2.fill")
                        .font(.caption2)
                    Text("\(party.participants.count)")
                        .font(.caption2)
                        .fontWeight(.medium)
                }
                .foregroundColor(.secondary)
                
                // Distance (if available)
                if let location = currentLocation,
                   let distanceText = party.formattedDistance(to: location) {
                    Text(distanceText)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
            }
        }
        .padding(12)
        .background(Color(.systemGray6))
        .cornerRadius(8)
        .frame(width: 200)
    }
}

// MARK: - Party Preview Card
struct PartyPreviewCard: View {
    let party: Party
    let currentLocation: CLLocation?
    let formatFollowerCount: (Int) -> String
    let onJoin: () -> Void
    @State private var showingPreview = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    HStack(spacing: 4) {
                        Text(party.name)
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        // Verified badge for influencers
                        if party.isInfluencerParty && party.isVerified {
                            Image(systemName: "checkmark.seal.fill")
                                .foregroundColor(.blue)
                                .font(.caption)
                        }
                    }
                    
                    HStack(spacing: 8) {
                        // Host profile picture
                        Circle()
                            .fill(Color.purple.opacity(0.2))
                            .frame(width: 24, height: 24)
                            .overlay(
                                Image(systemName: "person.fill")
                                    .foregroundColor(.purple)
                                    .font(.system(size: 12))
                            )
                            .onTapGesture {
                                NotificationCenter.default.post(name: NSNotification.Name("OpenUserProfile"), object: party.hostId)
                            }
                        
                        VStack(alignment: .leading, spacing: 2) {
                            HStack(spacing: 0) {
                                Text("Hosted by ")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                                
                                Text(party.hostName)
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.purple)
                                    .onTapGesture {
                                        NotificationCenter.default.post(name: NSNotification.Name("OpenUserProfile"), object: party.hostId)
                                    }
                            }
                            
                            // Additional indicators
                            HStack(spacing: 4) {
                                // Follower count for influencers
                                if party.isInfluencerParty, let followerCount = party.followerCount {
                                    Text("â€¢ \(formatFollowerCount(followerCount))")
                                        .font(.caption)
                                        .foregroundColor(.purple)
                                }
                                
                                // Friends-only indicator
                                if party.isFriendsParty && party.friendsOnly {
                                    Text("â€¢ Friends Only")
                                        .font(.caption)
                                        .foregroundColor(.green)
                                }
                            }
                        }
                    }
                }
                
                Spacer()
                
                HStack(spacing: 4) {
                    // Voice chat indicator
                    if party.voiceChatActive {
                        Image(systemName: "mic.fill")
                            .foregroundColor(.purple)
                            .font(.title3)
                    }
                    
                    // Location sharing indicator for friends
                    if party.isFriendsParty && party.locationSharingEnabled {
                        Image(systemName: "location.fill")
                            .foregroundColor(.blue)
                            .font(.title3)
                    }
                }
            }
            
            HStack {
                // Member count
                HStack(spacing: 4) {
                    Image(systemName: "person.2.fill")
                        .font(.caption)
                    Text("\(party.participants.count) members")
                        .font(.caption)
                }
                .foregroundColor(.secondary)
                
                Spacer()
                
                // Distance (if available)
                if let location = currentLocation,
                   let distanceText = party.formattedDistance(to: location) {
                    Text(distanceText)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            // Join button
            Button(action: {
                onJoin()
            }) {
                Text("Join Party")
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 8)
                    .background(Color.purple)
                    .cornerRadius(8)
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
        .onTapGesture {
            showingPreview = true
        }
        .sheet(isPresented: $showingPreview) {
            PartyPreviewView(
                party: party,
                currentLocation: currentLocation,
                onJoin: {
                    showingPreview = false
                    onJoin()
                }
            )
        }
    }
}

// MARK: - Missing View Components
struct PartyDetailView: View {
    let party: Party
    let onJoin: () -> Void
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                Text(party.name)
                    .font(.title)
                    .fontWeight(.bold)
                
                Text("Hosted by \(party.hostName)")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                if let description = party.descriptionText {
                    Text(description)
                        .font(.body)
                        .foregroundColor(.primary)
                }
                
                HStack {
                    Text("\(party.participants.count) participants")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Spacer()
                    
                    Button("Join Party") {
                        onJoin()
                        dismiss()
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.purple)
                }
            }
            .padding()
        }
        .navigationTitle("Party Details")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    dismiss()
                }
            }
        }
    }
}

// Duplicate MapFiltersView (simple List version) removed; using enhanced version below
/* struct MapFiltersView: View {
    @Binding var selectedFilter: MapFilter
    let onApply: (MapFilter) -> Void
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            List {
                ForEach(MapFilter.allCases, id: \.self) { filter in
                    Button(action: {
                        selectedFilter = filter
                        onApply(filter)
                        dismiss()
                    }) {
                        HStack {
                            Text(filter.displayName)
                                .foregroundColor(.primary)
                            Spacer()
                            if selectedFilter == filter {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.blue)
                            }
                        }
                    }
                }
            }
            .navigationTitle("Map Filters")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
} */









// Duplicate FriendRowView removed; using richer version defined later in file
/* struct FriendRowView: View {
    let friend: UserProfile
    let status: FriendStatus
    let isLocationSharing: Bool
    let onToggleLocationSharing: () -> Void
    
    var body: some View {
        HStack(spacing: 12) {
            // Profile picture
            if let profileUrl = friend.profilePictureUrl, let url = URL(string: profileUrl) {
                AsyncImage(url: url) { image in
                    image.resizable().scaledToFill()
                } placeholder: {
                    Color.gray.opacity(0.3)
                }
                .frame(width: 40, height: 40)
                .clipShape(Circle())
            } else {
                Circle()
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 40, height: 40)
                    .overlay(
                        Text(String(friend.displayName.prefix(1)).uppercased())
                            .font(.headline)
                            .foregroundColor(.white)
                    )
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text(friend.displayName)
                    .font(.headline)
                    .fontWeight(.medium)
                
                HStack(spacing: 8) {
                    // Status indicator
                    Circle()
                        .fill(status == .online ? Color.green : Color.gray)
                        .frame(width: 8, height: 8)
                    
                    Text(status == .online ? "Online" : "Offline")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    if isLocationSharing {
                        Image(systemName: "location.fill")
                            .foregroundColor(.blue)
                            .font(.caption)
                    }
                }
            }
            
            Spacer()
            
            Button(action: onToggleLocationSharing) {
                Image(systemName: isLocationSharing ? "location.fill" : "location.slash")
                    .foregroundColor(isLocationSharing ? .blue : .gray)
                    .font(.title3)
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
} */

// MARK: - Missing Data Models
// NOTE: Consolidated FriendStatus to a single definition (see Friend Status Enum below)
// Duplicate removed

// NOTE: Consolidated MapFilter to single enum at bottom of file. Duplicate removed.

enum MapFilter: String, CaseIterable {
    case all = "all"
    case friends = "friends"
    case following = "following"
    case trending = "trending"
    
    var displayName: String {
        switch self {
        case .all: return "All"
        case .friends: return "Friends"
        case .following: return "Following"
        case .trending: return "Trending"
        }
    }
}

enum ExploreFilter: String, CaseIterable {
    case all = "all"
    case trending = "trending"
    case influencers = "influencers"
    case djs = "djs"
    
    var displayName: String {
        switch self {
        case .all: return "All"
        case .trending: return "Trending"
        case .influencers: return "Influencers"
        case .djs: return "DJs"
        }
    }
}





// MARK: - Party Discovery Manager
@MainActor
class PartyDiscoveryManager: ObservableObject {
    @Published var followingParties: [Party] = []
    @Published var friendsParties: [Party] = []
    @Published var nearbyParties: [Party] = []
    @Published var exploreParties: [Party] = []
    @Published var isLoading = false
    private let cacheTTL: TimeInterval = 120 // seconds
    
    // Friends-specific properties
    @Published var friends: [UserProfile] = []
    @Published var friendsWithLocationSharing: [String] = []
    @Published var isLoadingFriends = false
    
    // Proximity-specific properties
    @Published var isAgeVerified = false
    @Published var isProximityDiscoveryEnabled = false
    @Published var showAgeVerificationAlert = false
    @Published var proximityRadius: Double = 402.336 // 0.25 miles in meters
    @Published var lastLocationUpdate: Date?
    @Published var locationValidationFailed = false
    
    // Explore-specific properties
    @Published var exploreFilter: ExploreFilter = .all
    @Published var trendingPartiesCount = 0
    @Published var activePartiesCount = 0
    @Published var popularPartiesCount = 0
    @Published var trendingAlgorithm = TrendingAlgorithm()
    // Pagination and display controls
    @Published var followingDisplayCount: Int = 20
    @Published var friendsDisplayCount: Int = 20
    @Published var explorePageSize: Int = 20
    @Published var exploreHasMore: Bool = false
    private var exploreLastDoc: DocumentSnapshot? = nil
    private var followingLastDocByHost: [String: DocumentSnapshot] = [:] // hostId -> last doc
    private var friendsLastDocByHost: [String: DocumentSnapshot] = [:]
    private var currentFollowingIds: [String] = []
    private var currentFriendIds: [String] = []
    @Published var isLoadingMoreFollowing = false
    @Published var isLoadingMoreFriends = false
    @Published var isLoadingMoreExplore = false
    @Published var isFetchingFollowingHostPages = false
    @Published var isFetchingFriendsHostPages = false
    #if DEBUG
    func performMockLoad() {
        loadMockParties()
        print("ðŸŽ‰ Mock data loaded - Nearby parties: \(nearbyParties.count)")
        Task { @MainActor in self.isLoading = false }
    }
    #endif

    // Simple client-side pagination steps (can be replaced with server cursors later)
    @MainActor
    func loadMoreFollowing(step: Int = 20) {
        followingDisplayCount = min(followingDisplayCount + step, followingParties.count)
        AnalyticsService.shared.logDiscoveryLoadMore(tab: "following", added: step)
        // If we already show all locally known items but still have hosts, fetch next page per host
        if followingDisplayCount >= followingParties.count {
            Task { await fetchMoreForHosts(hostIds: currentFollowingIds, markFriends: false, isFollowing: true) }
        }
    }
    @MainActor
    func loadMoreFriends(step: Int = 20) {
        friendsDisplayCount = min(friendsDisplayCount + step, friendsParties.count)
        AnalyticsService.shared.logDiscoveryLoadMore(tab: "friends", added: step)
        if friendsDisplayCount >= friendsParties.count {
            Task { await fetchMoreForHosts(hostIds: currentFriendIds, markFriends: true, isFollowing: false) }
        }
    }

    // Fetch additional pages per host to enrich local lists
    private func fetchMoreForHosts(hostIds: [String], markFriends: Bool = false, isFollowing: Bool) async {
        let db = Firestore.firestore()
        let pageSize = 10
        // Flip fetching flag
        await MainActor.run { if isFollowing { self.isFetchingFollowingHostPages = true } else { self.isFetchingFriendsHostPages = true } }
        defer { Task { @MainActor in if isFollowing { self.isFetchingFollowingHostPages = false } else { self.isFetchingFriendsHostPages = false } } }
        await withTaskGroup(of: Void.self) { group in
            for hid in hostIds.prefix(10) { // limit fan-out
                group.addTask {
                    var q: Query = db.collection("parties").whereField("isActive", isEqualTo: true).whereField("hostId", isEqualTo: hid).order(by: "createdAt", descending: true).limit(to: pageSize)
                    let last: DocumentSnapshot? = await MainActor.run { isFollowing ? self.followingLastDocByHost[hid] : self.friendsLastDocByHost[hid] }
                    if let last { q = q.start(afterDocument: last) }
                    do {
                        let snap = try await q.getDocuments()
                        let docs = snap.documents
                        var items = docs.compactMap { try? $0.data(as: Party.self) }
                        if markFriends {
                            items = items.map { p in var u = p; u.isFriendsParty = true; u.friendsOnly = true; u.locationSharingEnabled = true; return u }
                        }
                        await MainActor.run {
                            if isFollowing {
                                self.followingLastDocByHost[hid] = docs.last ?? self.followingLastDocByHost[hid]
                            } else {
                                self.friendsLastDocByHost[hid] = docs.last ?? self.friendsLastDocByHost[hid]
                            }
                            // Append and de-dup by id
                            var byId = Dictionary(uniqueKeysWithValues: (markFriends ? self.friendsParties : self.followingParties).map { ($0.id, $0) })
                            for it in items { byId[it.id] = it }
                            var merged = Array(byId.values)
                            merged.sort { $0.createdAt > $1.createdAt }
                            if markFriends { self.friendsParties = merged } else { self.followingParties = merged }
                        }
                    } catch {
                        // ignore
                    }
                }
            }
        }
    }
    
    // Map-specific properties
    @Published var mapFilter: MapFilter = .all
    
    var locationManager: LocationManager?
    private var firestore = Firestore.firestore()
    private var listeners: [ListenerRegistration] = []
    // Individual listener registrations to allow fine-grained attach/detach per tab
    private var nearbyReg: ListenerRegistration? = nil
    private var exploreReg: ListenerRegistration? = nil
    private var followingUserDocReg: ListenerRegistration? = nil
    private var friendsProfilesReg: ListenerRegistration? = nil
    // Backoff counters for retry with jitter
    private var retryCounts: [String: Int] = [:]

    // MARK: - Geo helpers
    /// Returns a simple lat/lon bounding box around a coordinate for a given radius in meters.
    /// This is an approximation sufficient for short-radius proximity queries.
    static func boundingBox(center: CLLocationCoordinate2D, radiusMeters: Double) -> (minLat: Double, maxLat: Double, minLon: Double, maxLon: Double) {
        let earthRadiusMeters: Double = 6_371_000
        // 1 degree latitude in meters ~ 111,320
        let latDelta = (radiusMeters / 111_320.0)
        let latRad = center.latitude * .pi / 180
        let metersPerDegreeLon = cos(latRad) * 111_320.0
        // Avoid division by zero near the poles
        let lonDelta = metersPerDegreeLon > 0 ? (radiusMeters / metersPerDegreeLon) : 180
        let minLat = center.latitude - latDelta
        let maxLat = center.latitude + latDelta
        let minLon = center.longitude - lonDelta
        let maxLon = center.longitude + lonDelta
        return (minLat, maxLat, minLon, maxLon)
    }
    // Additional listener groups for chunked queries
    private var followingPartyListeners: [ListenerRegistration] = []
    private var friendsPartyListeners: [ListenerRegistration] = []
    // Batch buffers for de-dup/aggregation
    private var followingBatchParties: [String: [Party]] = [:]
    private var friendsBatchParties: [String: [Party]] = [:]
    
    var currentParties: [Party] {
        switch selectedTab {
        case 0: return followingParties
        case 1: return friendsParties
        case 2: return nearbyParties
        case 3: return exploreParties
        default: return []
        }
    }
    
    // Get parties for a specific tab
    func getParties(for tab: Int) -> [Party] {
        switch tab {
        case 0: return followingParties
        case 1: return friendsParties
        case 2: return nearbyParties
        case 3: return exploreParties
        default: return []
        }
    }
    
    @Published var selectedTab = 0
    
    func startDiscovery(locationManager: LocationManager) async {
        self.locationManager = locationManager
        // Load cached results for a snappy cold start
        if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "explore", maxAgeSeconds: cacheTTL) { self.exploreParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "explore", hit: true, ageMs: Int(hit.ageSeconds*1000)) } else { AnalyticsService.shared.logDiscoveryCache(event: "load", source: "explore", hit: false, ageMs: nil) }
        if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "following", maxAgeSeconds: cacheTTL) { self.followingParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "following", hit: true, ageMs: Int(hit.ageSeconds*1000)) } else { AnalyticsService.shared.logDiscoveryCache(event: "load", source: "following", hit: false, ageMs: nil) }
        if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "friends", maxAgeSeconds: cacheTTL) { self.friendsParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "friends", hit: true, ageMs: Int(hit.ageSeconds*1000)) } else { AnalyticsService.shared.logDiscoveryCache(event: "load", source: "friends", hit: false, ageMs: nil) }
        if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "nearby", maxAgeSeconds: cacheTTL) { self.nearbyParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "nearby", hit: true, ageMs: Int(hit.ageSeconds*1000)) } else { AnalyticsService.shared.logDiscoveryCache(event: "load", source: "nearby", hit: false, ageMs: nil) }
        setupFirestoreListeners()
        loadProximitySettings()
        
        // Load initial data
        loadFriends() // populate following list and friends
        await loadFollowingParties() // parties from people you follow
        let t0 = Date()
        await loadExploreParties() // Load explore parties on startup
        AnalyticsService.shared.logTiming(name: "discover_initial_explore_load_ms", ms: Int(Date().timeIntervalSince(t0)*1000))
    }

    func resumeIfNeeded(locationManager: LocationManager) async {
        // When resuming app, re-attach listeners and optionally show cached content immediately
        self.locationManager = locationManager
        if listeners.isEmpty && followingPartyListeners.isEmpty && friendsPartyListeners.isEmpty {
            if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "explore", maxAgeSeconds: cacheTTL) { self.exploreParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "explore", hit: true, ageMs: Int(hit.ageSeconds*1000)) }
            if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "following", maxAgeSeconds: cacheTTL) { self.followingParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "following", hit: true, ageMs: Int(hit.ageSeconds*1000)) }
            if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "friends", maxAgeSeconds: cacheTTL) { self.friendsParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "friends", hit: true, ageMs: Int(hit.ageSeconds*1000)) }
            if let hit = DiscoverDiskCache.shared.loadWithMeta(key: "nearby", maxAgeSeconds: cacheTTL) { self.nearbyParties = hit.parties; AnalyticsService.shared.logDiscoveryCache(event: "load", source: "nearby", hit: true, ageMs: Int(hit.ageSeconds*1000)) }
            setupFirestoreListeners()
        }
    }

    func manualRetry() {
        // Reset counters and reattach listeners once
        retryCounts.removeAll()
        stopDiscovery()
        setupFirestoreListeners()
        Task { await loadExploreParties() }
    }
    
    func stopDiscovery() {
        listeners.forEach { $0.remove() }
        listeners.removeAll()
        followingPartyListeners.forEach { $0.remove() }
        followingPartyListeners.removeAll()
        friendsPartyListeners.forEach { $0.remove() }
        friendsPartyListeners.removeAll()
        nearbyReg?.remove(); nearbyReg = nil
        exploreReg?.remove(); exploreReg = nil
        followingUserDocReg?.remove(); followingUserDocReg = nil
        friendsProfilesReg?.remove(); friendsProfilesReg = nil
        followingBatchParties.removeAll()
        friendsBatchParties.removeAll()
    }
    
    // MARK: - Refresh Parties
    @MainActor
    func refreshParties() async {
        isLoading = true
        
        // Refresh all party data concurrently
        await withTaskGroup(of: Void.self) { group in
            group.addTask { await self.loadFollowingParties() }
            group.addTask { await self.loadFriendsParties() }
            group.addTask { await self.loadNearbyParties() }
            group.addTask { await self.loadExploreParties() }
        }
        
        isLoading = false
    }
    
    // MARK: - Friends Management
    
    private func loadFriends() {
        guard Auth.auth().currentUser?.uid != nil else { return }
        
        isLoadingFriends = true
        
        // First get current user's following list (friends are people you follow)
        let db = Firestore.firestore()
        db.collection("users").document(Auth.auth().currentUser!.uid).getDocument { [weak self] snapshot, error in
            guard let self = self else { return }
            
            if let error = error {
                print("Error loading friends: \(error.localizedDescription)")
                self.isLoadingFriends = false
                return
            }
            
            guard let data = snapshot?.data(),
                  let following = data["following"] as? [String],
                  !following.isEmpty else {
                self.friends = []
                self.isLoadingFriends = false
                return
            }
            
            // Get friends' profiles
            self.fetchFriendsProfiles(followingIds: following) { friends in
                DispatchQueue.main.async {
                    self.friends = friends
                    self.isLoadingFriends = false
                    
                    // Load friends' parties
                    Task {
                        await self.loadFriendsParties()
                    }
                    
                    // Load location sharing preferences
                    self.loadLocationSharingPreferences()
                }
            }
        }
    }
    
    private func loadLocationSharingPreferences() {
        guard Auth.auth().currentUser?.uid != nil else { return }
        
        let db = Firestore.firestore()
        db.collection("users").document(Auth.auth().currentUser!.uid).getDocument { [weak self] snapshot, error in
            guard let self = self else { return }
            
            if let data = snapshot?.data(),
               let locationSharingWith = data["locationSharingWith"] as? [String] {
                DispatchQueue.main.async {
                    self.friendsWithLocationSharing = locationSharingWith
                }
            }
        }
    }
    
    private func fetchFriendsProfiles(followingIds: [String], completion: @escaping ([UserProfile]) -> Void) {
        let db = Firestore.firestore()
        let batches = followingIds.chunked(into: 10) // Firestore limit
        var allFriends: [UserProfile] = []
        let dispatchGroup = DispatchGroup()
        
        for batch in batches {
            dispatchGroup.enter()
            db.collection("users").whereField("uid", in: batch).getDocuments { snapshot, error in
                if let documents = snapshot?.documents {
                    let users = documents.compactMap { try? $0.data(as: UserProfile.self) }
                    allFriends.append(contentsOf: users)
                }
                dispatchGroup.leave()
            }
        }
        
        dispatchGroup.notify(queue: .main) {
            completion(allFriends)
        }
    }
    
    private func loadFriendsParties() async {
        guard !friends.isEmpty else {
            await MainActor.run {
                self.friendsParties = []
            }
            return
        }
        
        let friendIds = friends.map { $0.uid }
        let db = Firestore.firestore()
        
        do {
            // Get active parties from friends
            let snapshot = try await db.collection("parties")
                .whereField("isActive", isEqualTo: true)
                .whereField("hostId", in: friendIds)
                .getDocuments()
            
            let parties = snapshot.documents.compactMap { document -> Party? in
                if var party = try? document.data(as: Party.self) {
                    // Mark as friends party
                    party.isFriendsParty = true
                    party.friendsOnly = true
                    party.locationSharingEnabled = true
                    return party
                }
                return nil
            }
            
            await MainActor.run {
                self.friendsParties = parties
            }
        } catch {
            print("Error loading friends' parties: \(error.localizedDescription)")
            await MainActor.run {
                self.friendsParties = []
            }
        }
    }
    
    // MARK: - Location Sharing Controls
    
    func toggleLocationSharing(for friendId: String) {
        guard Auth.auth().currentUser?.uid != nil else { return }
        
        let db = Firestore.firestore()
        let userRef = db.collection("users").document(Auth.auth().currentUser!.uid)
        
        if friendsWithLocationSharing.contains(friendId) {
            // Remove from location sharing
            userRef.updateData([
                "locationSharingWith": FieldValue.arrayRemove([friendId])
            ]) { [weak self] error in
                if error == nil {
                    DispatchQueue.main.async {
                        self?.friendsWithLocationSharing.removeAll { $0 == friendId }
                    }
                }
            }
        } else {
            // Add to location sharing
            userRef.updateData([
                "locationSharingWith": FieldValue.arrayUnion([friendId])
            ]) { [weak self] error in
                if error == nil {
                    DispatchQueue.main.async {
                        self?.friendsWithLocationSharing.append(friendId)
                    }
                }
            }
        }
    }
    
    func isLocationSharingWith(friendId: String) -> Bool {
        return friendsWithLocationSharing.contains(friendId)
    }
    
    // MARK: - Friend Status
    
    private func getFriendStatus(for friendId: String) -> FriendStatus {
        // For now, return online if they have an active party
        let hasActiveParty = friendsParties.contains { $0.hostId == friendId }
        return hasActiveParty ? .online : .offline
    }
    
    // MARK: - Quick Join
    
    func quickJoinParty(_ party: Party) {
        // If offline, queue the action and return
        if !OfflineActionQueue.shared.isOnline {
            OfflineActionQueue.shared.enqueueJoinParty(party: party)
            return
        }
        // Admission gating
        if party.admissionMode == "friends" {
            let friendIds = friends.map { $0.uid }
            if !friendIds.contains(party.hostId) {
                NotificationCenter.default.post(name: NSNotification.Name("FriendsOnlyDenied"), object: party)
                return
            }
        }
        // Proceed to join
        NotificationCenter.default.post(name: NSNotification.Name("JoinParty"), object: party)
        AnalyticsService.shared.logPartyJoin(method: "discovery", partyId: party.id)
    }
    
    // MARK: - Following Parties
    
    private func loadFollowingParties() async {
        guard Auth.auth().currentUser?.uid != nil else { return }
        
        let db = Firestore.firestore()
        
        // Get current user's following list
        do {
            let snapshot = try await db.collection("users").document(Auth.auth().currentUser!.uid).getDocument()
            guard let data = snapshot.data(),
                  var following = data["following"] as? [String] else {
                return
            }
            following = following.filter { !$0.isEmpty }
            guard !following.isEmpty else { return }
            
            // Break into chunks of up to 10 IDs (Firestore 'in' limit) and aggregate
            let batches = following.chunked(into: 10)
            var aggregated: [Party] = []
            for batch in batches where !batch.isEmpty {
                let qSnap = try await db.collection("parties")
                    .whereField("isActive", isEqualTo: true)
                    .whereField("isPublic", isEqualTo: true)
                    .whereField("hostId", in: batch)
                    .getDocuments()
                let parties = qSnap.documents.compactMap { try? $0.data(as: Party.self) }
                aggregated.append(contentsOf: parties)
            }
            
            await MainActor.run {
                aggregated.sort { $0.createdAt > $1.createdAt }
                self.followingParties = aggregated
                DiscoverDiskCache.shared.save(key: "following", parties: aggregated)
            }
        } catch {
            print("Error loading following parties: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Proximity Management
    
    func verifyAge() {
        // In a real app, you might want to implement actual age verification
        // For now, we'll just set the flag
        isAgeVerified = true
        
        // Save to UserDefaults for persistence
        UserDefaults.standard.set(true, forKey: "isAgeVerified")
        
        // Load proximity settings after age verification
        loadProximitySettings()
    }
    
    func loadProximitySettings() {
        // Load age verification status
        isAgeVerified = UserDefaults.standard.bool(forKey: "isAgeVerified")
        
        // Load proximity discovery settings
        isProximityDiscoveryEnabled = UserDefaults.standard.bool(forKey: "isProximityDiscoveryEnabled")
        let savedRadius = UserDefaults.standard.double(forKey: "proximityRadiusMeters")
        if savedRadius > 0 { proximityRadius = savedRadius }
        
        // If age verified but proximity not set, default to disabled for privacy
        if isAgeVerified && UserDefaults.standard.object(forKey: "isProximityDiscoveryEnabled") == nil {
            isProximityDiscoveryEnabled = false
            UserDefaults.standard.set(false, forKey: "isProximityDiscoveryEnabled")
        }
    }
    
    func updateProximitySettings(enabled: Bool) {
        isProximityDiscoveryEnabled = enabled
        UserDefaults.standard.set(enabled, forKey: "isProximityDiscoveryEnabled")
        
        if enabled {
            // Start proximity discovery
            startProximityDiscovery()
        } else {
            // Stop proximity discovery
            stopProximityDiscovery()
        }
    }
    
    private func startProximityDiscovery() {
        guard isAgeVerified && isProximityDiscoveryEnabled else { return }
        UserDefaults.standard.set(proximityRadius, forKey: "proximityRadiusMeters")
        
        // Validate location before starting
        validateLocation { [weak self] isValid in
            DispatchQueue.main.async {
                if isValid {
                    self?.locationValidationFailed = false
                    Task {
                        await self?.loadNearbyParties()
                    }
                } else {
                    self?.locationValidationFailed = true
                    self?.isProximityDiscoveryEnabled = false
                    UserDefaults.standard.set(false, forKey: "isProximityDiscoveryEnabled")
                }
            }
        }
    }
    
    private func stopProximityDiscovery() {
        // Clear nearby parties when proximity is disabled
        nearbyParties = []
    }
    
    private func validateLocation(completion: @escaping (Bool) -> Void) {
        guard let location = locationManager?.currentLocation else {
            completion(false)
            return
        }
        
        // Basic location validation
        // Check if location is reasonable (not in the middle of the ocean, etc.)
        let lat = location.coordinate.latitude
        let lon = location.coordinate.longitude
        
        // Simple validation: check if coordinates are within reasonable bounds
        let isValidLat = lat >= -90 && lat <= 90
        let isValidLon = lon >= -180 && lon <= 180
        
        // Check for suspicious locations (middle of ocean, etc.)
        let isReasonableLocation = !isSuspiciousLocation(lat: lat, lon: lon)
        
        completion(isValidLat && isValidLon && isReasonableLocation)
    }
    
    private func isSuspiciousLocation(lat: Double, lon: Double) -> Bool {
        // Check for common spoofing locations
        let suspiciousLocations = [
            (0.0, 0.0), // Null Island
            (90.0, 0.0), // North Pole
            (-90.0, 0.0), // South Pole
            (0.0, 180.0), // International Date Line
            (0.0, -180.0) // International Date Line
        ]
        
        for (suspLat, suspLon) in suspiciousLocations {
            let distance = sqrt(pow(lat - suspLat, 2) + pow(lon - suspLon, 2))
            if distance < 0.1 { // Within 0.1 degrees
                return true
            }
        }
        
        return false
    }
    
    private func loadNearbyParties() async {
        guard let location = locationManager?.currentLocation else { return }
        
        let db = Firestore.firestore()
        
        do {
            // Query for public parties within proximity radius
            let snapshot = try await db.collection("parties")
                .whereField("isActive", isEqualTo: true)
                .whereField("isPublic", isEqualTo: true)
                .getDocuments()
            
            let allParties = snapshot.documents.compactMap { document -> Party? in
                try? document.data(as: Party.self)
            }
            
            // Filter by distance
            let nearbyParties = allParties.filter { party in
                guard let partyLocation = party.location else { return false }
                let distance = location.distance(from: partyLocation)
                return distance <= self.proximityRadius
            }
            
            await MainActor.run {
                self.nearbyParties = nearbyParties
            }
        } catch {
            print("Error loading nearby parties: \(error.localizedDescription)")
            await MainActor.run {
                self.nearbyParties = []
            }
        }
    }

    // MARK: - Pagination APIs
    @MainActor
    func loadMoreExplore() async {
        guard !isLoadingMoreExplore else { return }
        isLoadingMoreExplore = true
        defer { isLoadingMoreExplore = false }
        let db = Firestore.firestore()
        var q: Query = db.collection("parties").whereField("isActive", isEqualTo: true).whereField("isPublic", isEqualTo: true).order(by: "createdAt", descending: true).limit(to: explorePageSize)
        if let last = exploreLastDoc { q = q.start(afterDocument: last) }
        do {
            let snap = try await q.getDocuments()
            let items = snap.documents.compactMap { try? $0.data(as: Party.self) }
            exploreLastDoc = snap.documents.last ?? exploreLastDoc
            exploreHasMore = snap.documents.count == explorePageSize
            let before = exploreParties.count
            exploreParties.append(contentsOf: items)
            AnalyticsService.shared.logDiscoveryLoadMore(tab: "explore", added: exploreParties.count - before)
        } catch {
            exploreHasMore = false
        }
    }
    
    private func setupFirestoreListeners() {
        // Listen for nearby parties (proximity tab), using bounding-box prefilter if location available
        var nearbyQuery: Query = firestore.collection("parties")
            .whereField("isActive", isEqualTo: true)
            .whereField("isPublic", isEqualTo: true)
        if let loc = locationManager?.currentLocation, isAgeVerified && isProximityDiscoveryEnabled {
            let bounds = Self.boundingBox(center: loc.coordinate, radiusMeters: proximityRadius)
            nearbyQuery = nearbyQuery
                .whereField("latitude", isGreaterThan: bounds.minLat)
                .whereField("latitude", isLessThan: bounds.maxLat)
                .whereField("longitude", isGreaterThan: bounds.minLon)
                .whereField("longitude", isLessThan: bounds.maxLon)
        }
        let nearbyAttachT0 = Date()
        let nearbyListener = nearbyQuery.addSnapshotListener { [weak self] snapshot, error in
            guard let self = self,
                  let documents = snapshot?.documents else {
                let msg = error?.localizedDescription ?? "Unknown error"
                print("Error fetching nearby parties: \(msg)")
                AnalyticsService.shared.logDiscoveryListenerError(source: "nearby_listener", error: msg)
                CrashReporter.shared.logMessage("nearby_listener error: \(msg)")
                return
            }
            AnalyticsService.shared.logTiming(name: "discover_listener_nearby_first_snapshot_ms", ms: Int(Date().timeIntervalSince(nearbyAttachT0)*1000))
            let parties = documents.compactMap { try? $0.data(as: Party.self) }
            if self.isAgeVerified && self.isProximityDiscoveryEnabled, let location = self.locationManager?.currentLocation {
                let filtered = parties.filter { $0.isWithinDiscoveryRange(of: location, maxDistance: self.proximityRadius) }
                DispatchQueue.main.async { self.nearbyParties = filtered; DiscoverDiskCache.shared.save(key: "nearby", parties: filtered) }
            } else {
                DispatchQueue.main.async { self.nearbyParties = []; DiscoverDiskCache.shared.save(key: "nearby", parties: []) }
            }
        }
        listeners.append(nearbyListener)
        nearbyReg = nearbyListener
        
        // Listen for following parties (people you follow) with safe fan-out
        if let currentUserId = Auth.auth().currentUser?.uid {
            let followAttachT0 = Date()
            followingUserDocReg = firestore.collection("users").document(currentUserId).addSnapshotListener { [weak self] snapshot, _ in
                guard let data = snapshot?.data() else { return }
                var followingIds = data["following"] as? [String] ?? []
                // Sanitize to avoid empty 'in' arrays
                followingIds = followingIds.filter { !$0.isEmpty }
                self?.currentFollowingIds = followingIds
                // Reset previous listeners/buffers
                Task { @MainActor in
                    self?.followingPartyListeners.forEach { $0.remove() }
                    self?.followingPartyListeners.removeAll()
                    self?.followingBatchParties.removeAll()
                    self?.followingLastDocByHost.removeAll()
                }
                guard !followingIds.isEmpty else {
                    Task { @MainActor in self?.followingParties = []; DiscoverDiskCache.shared.save(key: "following", parties: []) }
                    return
                }
                let batches = followingIds.chunked(into: 10)
                for (index, batch) in batches.enumerated() {
                    if batch.isEmpty { continue }
                    let batchKey = "b\(index)"
                    func attach(_ manager: PartyDiscoveryManager) {
                        let db = Firestore.firestore()
                        let attachT0 = Date()
                        let listener = db.collection("parties")
                            .whereField("isActive", isEqualTo: true)
                            .whereField("isPublic", isEqualTo: true)
                            .whereField("hostId", in: batch)
                            .addSnapshotListener { snapshot, err in
                                if let err = err {
                                    AnalyticsService.shared.logDiscoveryListenerError(source: "following_batch_\(index)", error: err.localizedDescription)
                                    CrashReporter.shared.logMessage("following_batch_\(index) error: \(err.localizedDescription)")
                                    let key = "following_batch_\(index)"
                                    let attempt = (self?.retryCounts[key] ?? 0) + 1
                                    self?.retryCounts[key] = attempt
                                    if attempt > 5 { return }
                                    let backoff = min(32.0, pow(2.0, Double(attempt)))
                                    let jitter = Double.random(in: 0...0.5)
                                    AnalyticsService.shared.logDiscoveryRetry(source: key, attempt: attempt, backoffMs: Int((backoff + jitter)*1000))
                                    DispatchQueue.main.asyncAfter(deadline: .now() + backoff + jitter) {
                                        if let mgr = self { attach(mgr) }
                                    }
                                    return
                                }
                                self?.retryCounts["following_batch_\(index)"] = 0
                                AnalyticsService.shared.logTiming(name: "discover_listener_following_batch_first_snapshot_ms", ms: Int(Date().timeIntervalSince(attachT0)*1000), props: ["batch": index])
                                let docs = snapshot?.documents ?? []
                                let parties = docs.compactMap { try? $0.data(as: Party.self) }
                                // Save last doc per host id
                                for d in docs { if let hid = d.data()["hostId"] as? String { Task { @MainActor in manager.followingLastDocByHost[hid] = d } } }
                                Task { @MainActor in
                                    manager.followingBatchParties[batchKey] = parties
                                    var merged = manager.mergeBatches(manager.followingBatchParties)
                                    merged.sort { $0.createdAt > $1.createdAt }
                                    manager.followingParties = merged
                                    DiscoverDiskCache.shared.save(key: "following", parties: merged)
                                }
                            }
                        Task { @MainActor in manager.followingPartyListeners.append(listener) }
                    }
                    if let mgr = self { attach(mgr) }
                }
            }
        }
        
        // Listen for friends' parties (real-time updates) with safe fan-out
        friendsProfilesReg = firestore.collection("users")
            .document(Auth.auth().currentUser?.uid ?? "")
            .addSnapshotListener { [weak self] _, _ in
                Task { @MainActor in
                    self?.friendsPartyListeners.forEach { $0.remove() }
                    self?.friendsPartyListeners.removeAll()
                    self?.friendsBatchParties.removeAll()
                    self?.friendsLastDocByHost.removeAll()
                }
                var friendIds = self?.friends.map { $0.uid } ?? []
                friendIds = friendIds.filter { !$0.isEmpty }
                self?.currentFriendIds = friendIds
                guard !friendIds.isEmpty else {
                    Task { @MainActor in self?.friendsParties = []; DiscoverDiskCache.shared.save(key: "friends", parties: []) }
                    return
                }
                let batches = friendIds.chunked(into: 10)
                for (index, batch) in batches.enumerated() {
                    if batch.isEmpty { continue }
                    let batchKey = "f\(index)"
                    func attach(_ manager: PartyDiscoveryManager) {
                        let db = Firestore.firestore()
                        let attachT0 = Date()
                        let listener = db.collection("parties")
                            .whereField("isActive", isEqualTo: true)
                            .whereField("hostId", in: batch)
                            .addSnapshotListener { snapshot, err in
                                if let err = err {
                                    AnalyticsService.shared.logDiscoveryListenerError(source: "friends_batch_\(index)", error: err.localizedDescription)
                                    CrashReporter.shared.logMessage("friends_batch_\(index) error: \(err.localizedDescription)")
                                    let key = "friends_batch_\(index)"
                                    let attempt = (self?.retryCounts[key] ?? 0) + 1
                                    self?.retryCounts[key] = attempt
                                    if attempt > 5 { return }
                                    let backoff = min(32.0, pow(2.0, Double(attempt)))
                                    let jitter = Double.random(in: 0...0.5)
                                    AnalyticsService.shared.logDiscoveryRetry(source: key, attempt: attempt, backoffMs: Int((backoff + jitter)*1000))
                                    DispatchQueue.main.asyncAfter(deadline: .now() + backoff + jitter) {
                                        if let mgr = self { attach(mgr) }
                                    }
                                    return
                                }
                                self?.retryCounts["friends_batch_\(index)"] = 0
                                AnalyticsService.shared.logTiming(name: "discover_listener_friends_batch_first_snapshot_ms", ms: Int(Date().timeIntervalSince(attachT0)*1000), props: ["batch": index])
                                let docs = snapshot?.documents ?? []
                                var parties = docs.compactMap { try? $0.data(as: Party.self) }
                                parties = parties.map { p in
                                    var updated = p
                                    updated.isFriendsParty = true
                                    updated.friendsOnly = true
                                    updated.locationSharingEnabled = true
                                    return updated
                                }
                                // Save last doc per host id
                                for d in docs { if let hid = d.data()["hostId"] as? String { Task { @MainActor in manager.friendsLastDocByHost[hid] = d } } }
                                Task { @MainActor in
                                    manager.friendsBatchParties[batchKey] = parties
                                    var merged = manager.mergeBatches(manager.friendsBatchParties)
                                    merged.sort { $0.createdAt > $1.createdAt }
                                    manager.friendsParties = merged
                                    DiscoverDiskCache.shared.save(key: "friends", parties: merged)
                                }
                            }
                        Task { @MainActor in manager.friendsPartyListeners.append(listener) }
                    }
                    if let mgr = self { attach(mgr) }
                }
            }
        listeners.append(friendsProfilesReg!)
        
        // Listen for explore parties (explore tab)
        let exploreAttachT0 = Date()
        let exploreListener = firestore.collection("parties")
            .whereField("isActive", isEqualTo: true)
            .whereField("isPublic", isEqualTo: true)
            .addSnapshotListener { [weak self] snapshot, error in
                guard let self = self,
                      let documents = snapshot?.documents else {
                    print("Error fetching explore parties: \(error?.localizedDescription ?? "Unknown error")")
                    if let e = error { CrashReporter.shared.logMessage("explore_listener error: \(e.localizedDescription)") }
                    return
                }
                AnalyticsService.shared.logTiming(name: "discover_listener_explore_first_snapshot_ms", ms: Int(Date().timeIntervalSince(exploreAttachT0)*1000))
                
                let parties = documents.compactMap { document -> Party? in
                    try? document.data(as: Party.self)
                }
                
                // Apply trending algorithm and filters
                let processedParties = self.trendingAlgorithm.processParties(parties)
                let filteredParties = self.filterExploreParties(processedParties)
                
                DispatchQueue.main.async {
                    self.exploreParties = filteredParties
                    self.updateExploreStats(processedParties)
                    DiscoverDiskCache.shared.save(key: "explore", parties: filteredParties)
                }
            }
        listeners.append(exploreListener)
        exploreReg = exploreListener
    }

    // MARK: - Per-tab optimization: prune listeners when tab changes
    func setActiveTab(index: Int) {
        selectedTab = index
        pruneListenersForActiveTab()
    }
    


    private func pruneListenersForActiveTab() {
        switch selectedTab {
        case 0: // Following
            // Ensure following root listener exists
            if followingUserDocReg == nil, let uid = Auth.auth().currentUser?.uid {
                followingUserDocReg = firestore.collection("users").document(uid).addSnapshotListener { [weak self] _, _ in }
            }
            // Detach friends
            friendsPartyListeners.forEach { $0.remove() }
            friendsPartyListeners.removeAll()
            friendsProfilesReg?.remove(); friendsProfilesReg = nil
            // Detach nearby
            nearbyReg?.remove(); nearbyReg = nil
        case 1: // Friends
            followingPartyListeners.forEach { $0.remove() }
            followingPartyListeners.removeAll()
            followingUserDocReg?.remove(); followingUserDocReg = nil
            nearbyReg?.remove(); nearbyReg = nil
            if friendsProfilesReg == nil, let uid = Auth.auth().currentUser?.uid {
                friendsProfilesReg = firestore.collection("users").document(uid).addSnapshotListener { [weak self] _, _ in }
            }
        case 2: // Nearby
            followingPartyListeners.forEach { $0.remove() }
            followingPartyListeners.removeAll()
            followingUserDocReg?.remove(); followingUserDocReg = nil
            friendsPartyListeners.forEach { $0.remove() }
            friendsPartyListeners.removeAll()
            friendsProfilesReg?.remove(); friendsProfilesReg = nil
            if nearbyReg == nil {
                // Reattach nearby with current filters
                // Trigger by calling setup for nearby only
                // Simplest: call setupFirestoreListeners and then prune again
                setupFirestoreListeners(); pruneListenersForActiveTab(); return
            }
        case 3: // Explore
            followingPartyListeners.forEach { $0.remove() }
            followingPartyListeners.removeAll()
            followingUserDocReg?.remove(); followingUserDocReg = nil
            friendsPartyListeners.forEach { $0.remove() }
            friendsPartyListeners.removeAll()
            friendsProfilesReg?.remove(); friendsProfilesReg = nil
            nearbyReg?.remove(); nearbyReg = nil
        default:
            break
        }
    }
    
    private func loadParties() {
        isLoading = true
        
        // For now, load mock data
        loadMockParties()
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.isLoading = false
        }
    }
    
    private func loadMockParties() {
        // Mock data for testing with realistic coordinates
        var mockParties: [Party] = []
        var p0 = Party(name: "Chill Vibes", hostId: "u1", hostName: "Alex", latitude: 37.7749, longitude: -122.4194, isPublic: true)
        p0.musicQueue = [Song(title: "Midnight Drive", artist: "Astra", duration: 215), Song(title: "Neon Lights", artist: "Echo Wave", duration: 204)]
        p0.voiceChatEnabled = true
        p0.voiceChatActive = true
        p0.speakers = ["u1", "u2"]
        p0.listeners = ["u3", "u4", "u5"]
        p0.maxSpeakers = 4
        mockParties.append(p0)

        var p1 = Party(name: "Rock Night", hostId: "u2", hostName: "Sarah", latitude: 37.7849, longitude: -122.4094, isPublic: true)
        p1.musicQueue = [Song(title: "Stone Cold", artist: "The Rift", duration: 198), Song(title: "Afterburn", artist: "Voltrix", duration: 201)]
        p1.isShuffled = true
        mockParties.append(p1)

        var p2 = Party(name: "Hip Hop Session", hostId: "u3", hostName: "Mike", latitude: 37.7649, longitude: -122.4294, isPublic: true)
        p2.currentSong = Song(title: "Night Run", artist: "Kai Nova", duration: 188)
        mockParties.append(p2)

        var p3 = Party(name: "Jazz Lounge", hostId: "u4", hostName: "Emma", latitude: 37.7949, longitude: -122.4294, isPublic: true)
        p3.descriptionText = "Live quartet â€¢ Downtown"
        mockParties.append(p3)

        var p4 = Party(name: "Electronic Beats", hostId: "u5", hostName: "David", latitude: 37.7649, longitude: -122.4394, isPublic: true)
        p4.musicQueue = [Song(title: "Pulse", artist: "Lumen", duration: 200)]
        mockParties.append(p4)
        
        // Mock influencer parties for following tab
        var influencerParties: [Party] = []
        var i0 = Party(name: "Drake's Late Night", hostId: "drake", hostName: "Drake", latitude: 37.7749, longitude: -122.4194, isPublic: true, isInfluencerParty: true, influencerId: "drake", followerCount: 1500000, isVerified: true)
        i0.voiceChatEnabled = true; i0.voiceChatActive = true; i0.speakers = ["drake"]; i0.listeners = Array(repeating: "fan", count: 50)
        influencerParties.append(i0)
        var i1 = Party(name: "Taylor's Swift Session", hostId: "taylor", hostName: "Taylor Swift", latitude: 37.7849, longitude: -122.4094, isPublic: true, isInfluencerParty: true, influencerId: "taylor", followerCount: 2000000, isVerified: true)
        i1.musicQueue = [Song(title: "Lavender Sky", artist: "TS", duration: 210)]
        influencerParties.append(i1)
        influencerParties.append(Party(name: "The Weeknd Vibes", hostId: "weeknd", hostName: "The Weeknd", latitude: 37.7649, longitude: -122.4294, isPublic: true, isInfluencerParty: true, influencerId: "weeknd", followerCount: 1200000, isVerified: true))
        influencerParties.append(Party(name: "BTS Army Party", hostId: "bts", hostName: "BTS", latitude: 37.7949, longitude: -122.4294, isPublic: true, isInfluencerParty: true, influencerId: "bts", followerCount: 3000000, isVerified: true))
        influencerParties.append(Party(name: "Post Malone's Mix", hostId: "post", hostName: "Post Malone", latitude: 37.7649, longitude: -122.4394, isPublic: true, isInfluencerParty: true, influencerId: "post", followerCount: 800000, isVerified: true))
        
        // Mock friends' parties for friends tab
        var mockFriendsParties: [Party] = []
        var f0 = Party(name: "Sarah's Birthday Bash", hostId: "sarah", hostName: "Sarah", latitude: 37.7749, longitude: -122.4194, isPublic: true, isFriendsParty: true, friendsOnly: true, locationSharingEnabled: true)
        f0.currentSong = Song(title: "Party Time", artist: "Glow", duration: 180)
        mockFriendsParties.append(f0)
        var f1 = Party(name: "Mike's Study Session", hostId: "mike", hostName: "Mike", latitude: 37.7849, longitude: -122.4094, isPublic: true, isFriendsParty: true, friendsOnly: true, locationSharingEnabled: true)
        f1.musicQueue = [Song(title: "Lo-Fi 1", artist: "Beat Lab", duration: 190)]
        mockFriendsParties.append(f1)
        mockFriendsParties.append(Party(name: "Emma's Coffee Vibes", hostId: "emma", hostName: "Emma", latitude: 37.7649, longitude: -122.4294, isPublic: true, isFriendsParty: true, friendsOnly: true, locationSharingEnabled: true))
        var f3 = Party(name: "Alex's Gaming Night", hostId: "alex", hostName: "Alex", latitude: 37.7949, longitude: -122.4294, isPublic: true, isFriendsParty: true, friendsOnly: true, locationSharingEnabled: true)
        f3.voiceChatEnabled = true
        mockFriendsParties.append(f3)
        mockFriendsParties.append(Party(name: "David's Chill Session", hostId: "david", hostName: "David", latitude: 37.7649, longitude: -122.4394, isPublic: true, isFriendsParty: true, friendsOnly: true, locationSharingEnabled: true))
        
        // Mock nearby parties specifically for nearby tab
        var nearbyParties: [Party] = []
        
        // Parties at various distances (0.5 to 2.7 miles)
        var n0 = Party(name: "Downtown Coffee Shop", hostId: "coffee_host", hostName: "Jake", latitude: 37.7849, longitude: -122.4094, isPublic: true)
        n0.currentSong = Song(title: "Morning Brew", artist: "Acoustic Collective", duration: 195)
        n0.participants = [
            PartyParticipant(id: "coffee_host", name: "Jake", isHost: true),
            PartyParticipant(id: "user1", name: "Emma", isHost: false),
            PartyParticipant(id: "user2", name: "Marcus", isHost: false)
        ]
        n0.voiceChatEnabled = true
        n0.voiceChatActive = true
        n0.speakers = ["coffee_host"]
        n0.listeners = ["user1", "user2"]
        n0.descriptionText = "0.5 mi away â€¢ 3 people"
        nearbyParties.append(n0)
        
        var n1 = Party(name: "University Library Study", hostId: "study_host", hostName: "Sophia", latitude: 37.7949, longitude: -122.4194, isPublic: true)
        n1.musicQueue = [Song(title: "Lo-Fi Dreams", artist: "Study Beats", duration: 180), Song(title: "Focus Flow", artist: "Zen Music", duration: 200)]
        n1.participants = [
            PartyParticipant(id: "study_host", name: "Sophia", isHost: true),
            PartyParticipant(id: "user3", name: "Alex", isHost: false),
            PartyParticipant(id: "user4", name: "Jordan", isHost: false),
            PartyParticipant(id: "user5", name: "Taylor", isHost: false)
        ]
        n1.descriptionText = "1.2 mi away â€¢ 4 people"
        nearbyParties.append(n1)
        
        var n2 = Party(name: "Golden Gate Park Vibes", hostId: "park_host", hostName: "Riley", latitude: 37.8049, longitude: -122.4294, isPublic: true)
        n2.currentSong = Song(title: "Golden Hour", artist: "Indie Folk", duration: 220)
        n2.participants = [
            PartyParticipant(id: "park_host", name: "Riley", isHost: true),
            PartyParticipant(id: "user6", name: "Casey", isHost: false),
            PartyParticipant(id: "user7", name: "Morgan", isHost: false),
            PartyParticipant(id: "user8", name: "Quinn", isHost: false),
            PartyParticipant(id: "user9", name: "Avery", isHost: false),
            PartyParticipant(id: "user10", name: "Blake", isHost: false)
        ]
        n2.voiceChatEnabled = true
        n2.voiceChatActive = true
        n2.speakers = ["park_host", "user6"]
        n2.listeners = ["user7", "user8", "user9", "user10"]
        n2.descriptionText = "1.8 mi away â€¢ 6 people"
        nearbyParties.append(n2)
        
        var n3 = Party(name: "Fitness Center Mix", hostId: "gym_host", hostName: "Derek", latitude: 37.8149, longitude: -122.4394, isPublic: true)
        n3.musicQueue = [Song(title: "Power Up", artist: "Energy Boost", duration: 185), Song(title: "Pump It", artist: "Workout Beats", duration: 190)]
        n3.participants = [
            PartyParticipant(id: "gym_host", name: "Derek", isHost: true),
            PartyParticipant(id: "user11", name: "Zoe", isHost: false),
            PartyParticipant(id: "user12", name: "Kai", isHost: false)
        ]
        n3.descriptionText = "2.1 mi away â€¢ 3 people"
        nearbyParties.append(n3)
        
        var n4 = Party(name: "Mission District Night", hostId: "mission_host", hostName: "Luna", latitude: 37.8249, longitude: -122.4494, isPublic: true)
        n4.currentSong = Song(title: "City Lights", artist: "Urban Vibes", duration: 210)
        n4.participants = [
            PartyParticipant(id: "mission_host", name: "Luna", isHost: true),
            PartyParticipant(id: "user13", name: "River", isHost: false),
            PartyParticipant(id: "user14", name: "Sky", isHost: false),
            PartyParticipant(id: "user15", name: "Ocean", isHost: false),
            PartyParticipant(id: "user16", name: "Forest", isHost: false),
            PartyParticipant(id: "user17", name: "Mountain", isHost: false),
            PartyParticipant(id: "user18", name: "Valley", isHost: false)
        ]
        n4.voiceChatEnabled = true
        n4.voiceChatActive = true
        n4.speakers = ["mission_host", "user13", "user14"]
        n4.listeners = ["user15", "user16", "user17", "user18"]
        n4.descriptionText = "2.4 mi away â€¢ 7 people"
        nearbyParties.append(n4)
        
        var n5 = Party(name: "North Beach Jazz", hostId: "jazz_host", hostName: "Miles", latitude: 37.8349, longitude: -122.4594, isPublic: true)
        n5.musicQueue = [Song(title: "Smooth Jazz", artist: "Cafe Collective", duration: 240), Song(title: "Evening Blues", artist: "Jazz Trio", duration: 225)]
        n5.participants = [
            PartyParticipant(id: "jazz_host", name: "Miles", isHost: true),
            PartyParticipant(id: "user19", name: "Ella", isHost: false),
            PartyParticipant(id: "user20", name: "Louis", isHost: false),
            PartyParticipant(id: "user21", name: "Billie", isHost: false)
        ]
        n5.descriptionText = "2.7 mi away â€¢ 4 people"
        nearbyParties.append(n5)
        
        // Add one more party just outside the 2.75 mile range to test filtering
        var n6 = Party(name: "Marina District Sunset", hostId: "marina_host", hostName: "Sofia", latitude: 37.8449, longitude: -122.4694, isPublic: true)
        n6.currentSong = Song(title: "Ocean Waves", artist: "Coastal Vibes", duration: 195)
        n6.participants = [
            PartyParticipant(id: "marina_host", name: "Sofia", isHost: true),
            PartyParticipant(id: "user22", name: "Marco", isHost: false),
            PartyParticipant(id: "user23", name: "Isabella", isHost: false)
        ]
        n6.descriptionText = "3.2 mi away â€¢ 3 people"
        nearbyParties.append(n6)
        
        // Mock explore parties (trending, influencers, DJs)
        var exploreParties: [Party] = []
        
        // Trending Parties (high engagement, lots of participants)
        var t0 = Party(name: "Friday Night Vibes", hostId: "trending1", hostName: "Alex", latitude: 37.7749, longitude: -122.4194, isPublic: true)
        t0.participants = Array(0..<15).map { i in PartyParticipant(id: "user\(i)", name: "User\(i)", isHost: false) }
        t0.participants.insert(PartyParticipant(id: "trending1", name: "Alex", isHost: true), at: 0)
        t0.currentSong = Song(title: "Midnight Groove", artist: "The Collective", duration: 210)
        t0.voiceChatEnabled = true
        t0.voiceChatActive = true
        t0.speakers = ["trending1", "user1", "user2"]
        t0.trendingScore = 0.9
        t0.descriptionText = "16 people â€¢ Active voice chat"
        exploreParties.append(t0)
        
        var t1 = Party(name: "Campus Party Central", hostId: "trending2", hostName: "Sarah", latitude: 37.7849, longitude: -122.4094, isPublic: true)
        t1.participants = Array(0..<12).map { i in PartyParticipant(id: "user\(i+20)", name: "User\(i+20)", isHost: false) }
        t1.participants.insert(PartyParticipant(id: "trending2", name: "Sarah", isHost: true), at: 0)
        t1.musicQueue = [Song(title: "Party Anthem", artist: "Campus Beats", duration: 195)]
        t1.trendingScore = 0.8
        t1.descriptionText = "13 people â€¢ Trending"
        exploreParties.append(t1)
        
        var t2 = Party(name: "Downtown Dance Night", hostId: "trending3", hostName: "Mike", latitude: 37.7649, longitude: -122.4294, isPublic: true)
        t2.participants = Array(0..<20).map { i in PartyParticipant(id: "user\(i+40)", name: "User\(i+40)", isHost: false) }
        t2.participants.insert(PartyParticipant(id: "trending3", name: "Mike", isHost: true), at: 0)
        t2.currentSong = Song(title: "Electric Dreams", artist: "Neon Pulse", duration: 225)
        t2.voiceChatEnabled = true
        t2.voiceChatActive = true
        t2.speakers = ["trending3", "user41", "user42", "user43"]
        t2.trendingScore = 0.95
        t2.descriptionText = "21 people â€¢ Hot right now"
        exploreParties.append(t2)
        
        // Additional trending parties
        var t3 = Party(name: "Late Night Study Group", hostId: "trending4", hostName: "Emma", latitude: 37.7749, longitude: -122.4194, isPublic: true)
        t3.participants = Array(0..<10).map { i in PartyParticipant(id: "student\(i)", name: "Student\(i)", isHost: false) }
        t3.participants.insert(PartyParticipant(id: "trending4", name: "Emma", isHost: true), at: 0)
        t3.musicQueue = [Song(title: "Study Vibes", artist: "Lo-Fi Collective", duration: 180)]
        t3.trendingScore = 0.75
        t3.descriptionText = "11 people â€¢ Study session"
        exploreParties.append(t3)
        
        var t4 = Party(name: "Weekend Warriors", hostId: "trending5", hostName: "Chris", latitude: 37.7849, longitude: -122.4094, isPublic: true)
        t4.participants = Array(0..<18).map { i in PartyParticipant(id: "warrior\(i)", name: "Warrior\(i)", isHost: false) }
        t4.participants.insert(PartyParticipant(id: "trending5", name: "Chris", isHost: true), at: 0)
        t4.currentSong = Song(title: "Weekend Anthem", artist: "Party Crew", duration: 195)
        t4.voiceChatEnabled = true
        t4.voiceChatActive = true
        t4.speakers = ["trending5", "warrior1", "warrior2"]
        t4.trendingScore = 0.85
        t4.descriptionText = "19 people â€¢ Weekend vibes"
        exploreParties.append(t4)
        
        // DJ Parties
        var d0 = Party(name: "DJ Max's House Mix", hostId: "dj_max", hostName: "DJ Max", latitude: 37.7949, longitude: -122.4294, isPublic: true)
        d0.currentSong = Song(title: "Deep House Groove", artist: "DJ Max", duration: 240)
        d0.participants = Array(0..<8).map { i in PartyParticipant(id: "listener\(i)", name: "Listener\(i)", isHost: false) }
        d0.participants.insert(PartyParticipant(id: "dj_max", name: "DJ Max", isHost: true), at: 0)
        d0.voiceChatEnabled = true
        d0.voiceChatActive = true
        d0.speakers = ["dj_max"]
        d0.listeners = Array(0..<8).map { "listener\($0)" }
        d0.descriptionText = "9 people â€¢ Live mixing"
        exploreParties.append(d0)
        
        var d1 = Party(name: "DJ Luna's Electronic Set", hostId: "dj_luna", hostName: "DJ Luna", latitude: 37.7649, longitude: -122.4394, isPublic: true)
        d1.musicQueue = [Song(title: "Synthwave Journey", artist: "DJ Luna", duration: 280), Song(title: "Digital Dreams", artist: "DJ Luna", duration: 265)]
        d1.participants = Array(0..<12).map { i in PartyParticipant(id: "raver\(i)", name: "Raver\(i)", isHost: false) }
        d1.participants.insert(PartyParticipant(id: "dj_luna", name: "DJ Luna", isHost: true), at: 0)
        d1.descriptionText = "13 people â€¢ Electronic vibes"
        exploreParties.append(d1)
        
        var d2 = Party(name: "DJ Carlos Latin Mix", hostId: "dj_carlos", hostName: "DJ Carlos", latitude: 37.7549, longitude: -122.4494, isPublic: true)
        d2.currentSong = Song(title: "Salsa Caliente", artist: "DJ Carlos", duration: 200)
        d2.participants = Array(0..<6).map { i in PartyParticipant(id: "dancer\(i)", name: "Dancer\(i)", isHost: false) }
        d2.participants.insert(PartyParticipant(id: "dj_carlos", name: "DJ Carlos", isHost: true), at: 0)
        d2.voiceChatEnabled = true
        d2.voiceChatActive = true
        d2.speakers = ["dj_carlos"]
        d2.descriptionText = "7 people â€¢ Latin rhythms"
        exploreParties.append(d2)
        
        // Additional DJ parties
        var d3 = Party(name: "DJ Maya's Hip Hop Set", hostId: "dj_maya", hostName: "DJ Maya", latitude: 37.7649, longitude: -122.4294, isPublic: true)
        d3.currentSong = Song(title: "Beats & Rhymes", artist: "DJ Maya", duration: 220)
        d3.participants = Array(0..<9).map { i in PartyParticipant(id: "hiphopper\(i)", name: "HipHopper\(i)", isHost: false) }
        d3.participants.insert(PartyParticipant(id: "dj_maya", name: "DJ Maya", isHost: true), at: 0)
        d3.descriptionText = "10 people â€¢ Hip hop vibes"
        exploreParties.append(d3)
        
        var d4 = Party(name: "DJ Sam's Rock Mix", hostId: "dj_sam", hostName: "DJ Sam", latitude: 37.7749, longitude: -122.4194, isPublic: true)
        d4.musicQueue = [Song(title: "Rock Anthem", artist: "DJ Sam", duration: 250), Song(title: "Guitar Solo", artist: "DJ Sam", duration: 180)]
        d4.participants = Array(0..<5).map { i in PartyParticipant(id: "rocker\(i)", name: "Rocker\(i)", isHost: false) }
        d4.participants.insert(PartyParticipant(id: "dj_sam", name: "DJ Sam", isHost: true), at: 0)
        d4.voiceChatEnabled = true
        d4.voiceChatActive = true
        d4.speakers = ["dj_sam"]
        d4.descriptionText = "6 people â€¢ Rock classics"
        exploreParties.append(d4)
        
        // Influencer Parties (these will be filtered by the computed property)
        var inf0 = Party(name: "Drake's Late Night", hostId: "drake", hostName: "Drake", latitude: 37.7749, longitude: -122.4194, isPublic: true, isInfluencerParty: true, influencerId: "drake", followerCount: 1500000, isVerified: true)
        inf0.voiceChatEnabled = true; inf0.voiceChatActive = true; inf0.speakers = ["drake"]; inf0.listeners = Array(repeating: "fan", count: 50)
        inf0.descriptionText = "51 people â€¢ Verified artist"
        exploreParties.append(inf0)
        
        var inf1 = Party(name: "Taylor's Swift Session", hostId: "taylor", hostName: "Taylor Swift", latitude: 37.7849, longitude: -122.4094, isPublic: true, isInfluencerParty: true, influencerId: "taylor", followerCount: 2000000, isVerified: true)
        inf1.musicQueue = [Song(title: "Lavender Sky", artist: "TS", duration: 210)]
        inf1.descriptionText = "1 person â€¢ Verified artist"
        exploreParties.append(inf1)
        
        var inf2 = Party(name: "The Weeknd Vibes", hostId: "weeknd", hostName: "The Weeknd", latitude: 37.7649, longitude: -122.4294, isPublic: true, isInfluencerParty: true, influencerId: "weeknd", followerCount: 1200000, isVerified: true)
        inf2.descriptionText = "1 person â€¢ Verified artist"
        exploreParties.append(inf2)
        
        var inf3 = Party(name: "BTS Army Party", hostId: "bts", hostName: "BTS", latitude: 37.7949, longitude: -122.4294, isPublic: true, isInfluencerParty: true, influencerId: "bts", followerCount: 3000000, isVerified: true)
        inf3.descriptionText = "1 person â€¢ Verified artist"
        exploreParties.append(inf3)
        
        var inf4 = Party(name: "Post Malone's Mix", hostId: "post", hostName: "Post Malone", latitude: 37.7649, longitude: -122.4394, isPublic: true, isInfluencerParty: true, influencerId: "post", followerCount: 800000, isVerified: true)
        inf4.descriptionText = "1 person â€¢ Verified artist"
        exploreParties.append(inf4)
        
        var inf5 = Party(name: "Ariana's Pop Session", hostId: "ariana", hostName: "Ariana Grande", latitude: 37.7549, longitude: -122.4494, isPublic: true, isInfluencerParty: true, influencerId: "ariana", followerCount: 1800000, isVerified: true)
        inf5.currentSong = Song(title: "Pop Star", artist: "Ariana Grande", duration: 200)
        inf5.descriptionText = "1 person â€¢ Verified artist"
        exploreParties.append(inf5)
        
        // Always load mock data for testing, regardless of location availability
            self.followingParties = influencerParties
            self.friendsParties = mockFriendsParties
            self.nearbyParties = nearbyParties
            self.exploreParties = exploreParties
    }
    
    // MARK: - Explore Management
    
    func loadExploreParties() async {
        guard Auth.auth().currentUser?.uid != nil else { return }
        
        let db = Firestore.firestore()
        
        do {
            // Query for all public parties
            let snapshot = try await db.collection("parties")
                .whereField("isActive", isEqualTo: true)
                .whereField("isPublic", isEqualTo: true)
                .getDocuments()
            
            let allParties = snapshot.documents.compactMap { document -> Party? in
                try? document.data(as: Party.self)
            }
            
            // Apply trending algorithm and filters
            let processedParties = self.trendingAlgorithm.processParties(allParties)
            let filteredParties = self.filterExploreParties(processedParties)
            
            await MainActor.run {
                self.exploreParties = filteredParties
                self.updateExploreStats(processedParties)
            }
        } catch {
            print("Error loading explore parties: \(error.localizedDescription)")
            await MainActor.run {
                self.exploreParties = []
            }
        }
    }
    
    private func filterExploreParties(_ parties: [Party]) -> [Party] {
        switch exploreFilter {
        case .all:
            return parties
        case .trending:
            return parties.filter { $0.trendingScore ?? 0 > 0.7 }
        case .popular:
            return parties.filter { $0.participants.count > 5 }
        case .new:
            return parties.filter { party in
                let hoursSinceCreation = Date().timeIntervalSince(party.createdAt) / 3600
                return hoursSinceCreation < 24 // Less than 24 hours old
            }
        }
    }
    
    private func updateExploreStats(_ parties: [Party]) {
        trendingPartiesCount = parties.filter { $0.trendingScore ?? 0 > 0.7 }.count
        activePartiesCount = parties.filter { $0.isActive }.count
        popularPartiesCount = parties.filter { $0.participants.count > 5 }.count
    }
    
    // MARK: - Explore Filter Enum
    enum ExploreFilter: String, CaseIterable {
        case all = "all"
        case trending = "trending"
        case popular = "popular"
        case new = "new"
        
        var displayName: String {
            switch self {
            case .all: return "All Parties"
            case .trending: return "Trending Now"
            case .popular: return "Most Popular"
            case .new: return "New & Fresh"
            }
        }
    }
    
    // MARK: - Trending Algorithm
    class TrendingAlgorithm {
        func processParties(_ parties: [Party]) -> [Party] {
            return parties.map { party in
                var updatedParty = party
                updatedParty.trendingScore = calculateTrendingScore(party)
                updatedParty.socialProof = calculateSocialProof(party)
                return updatedParty
            }.sorted { $0.trendingScore ?? 0 > $1.trendingScore ?? 0 }
        }
        
        private func calculateTrendingScore(_ party: Party) -> Double {
            var score: Double = 0
            
            // Member count weight (30%)
            let memberScore = min(Double(party.participants.count) / 10.0, 1.0) * 0.3
            score += memberScore
            
            // Recent activity weight (25%)
            if let lastActivity = party.lastActivity {
                let hoursSinceActivity = Date().timeIntervalSince(lastActivity) / 3600
                let activityScore = max(0, 1 - (hoursSinceActivity / 24)) * 0.25
                score += activityScore
            }
            
            // Voice chat activity weight (20%)
            if party.voiceChatActive {
                score += 0.2
            }
            
            // New party bonus (15%)
            let hoursSinceCreation = Date().timeIntervalSince(party.createdAt) / 3600
            if hoursSinceCreation < 6 { // Less than 6 hours old
                score += 0.15
            }
            
            // Influencer bonus (10%)
            if party.isInfluencerParty {
                score += 0.1
            }
            
            return min(score, 1.0)
        }
        
        private func calculateSocialProof(_ party: Party) -> SocialProof {
            var proof = SocialProof()
            
            // Member count proof
            if party.participants.count > 10 {
                proof.memberCountProof = "ðŸ”¥ \(party.participants.count) people jamming"
            } else if party.participants.count > 5 {
                proof.memberCountProof = "âš¡ \(party.participants.count) people active"
            }
            
            // Voice chat proof
            if party.voiceChatActive {
                proof.voiceChatProof = "ðŸŽ¤ Live voice chat"
            }
            
            // Influencer proof
            if party.isInfluencerParty {
                proof.influencerProof = "â­ Verified influencer"
            }
            
            // Recent activity proof
            if let lastActivity = party.lastActivity {
                let minutesSinceActivity = Date().timeIntervalSince(lastActivity) / 60
                if minutesSinceActivity < 5 {
                    proof.recentActivityProof = "ðŸŸ¢ Just active"
                } else if minutesSinceActivity < 30 {
                    proof.recentActivityProof = "ðŸŸ¡ Active recently"
                }
            }
            
            return proof
        }
    }
    
    // MARK: - Social Proof Structure
    // Note: SocialProof is already defined in Party.swift
    
    // MARK: - Final Polish & Performance
    
    func optimizeMapPerformance() {
        // Implement clustering for better performance with many parties
        _ = 50 // reserved for future clustering thresholds
        // Note: currentParties is a computed property, so we can't assign to it
        // In a real implementation, we would implement clustering logic here
        print("Map performance optimization: \(currentParties.count) parties visible")
    }
    
    func updateMapInRealTime() {
        // Update map every 30 seconds for real-time experience using Task loop
        Task { [weak self] in
            while !Task.isCancelled {
                if let self = self {
                    await self.refreshParties()
                }
                try? await Task.sleep(nanoseconds: 30_000_000_000)
            }
        }
    }
    
    // MARK: - Analytics & Insights
    
    func trackPartyDiscovery() {
        // Track discovery metrics for analytics
        let discoveryMetrics = [
            "following_count": followingParties.count,
            "friends_count": friendsParties.count,
            "nearby_count": nearbyParties.count,
            "explore_count": exploreParties.count,
            "total_active": currentParties.count
        ]
        
        // In a real app, send to analytics service
        print("Discovery Metrics: \(discoveryMetrics)")
    }
    
    // MARK: - Error Handling & Recovery
    
    func handleDiscoveryError(_ error: Error) {
        print("Discovery Error: \(error.localizedDescription)")
        
        // Implement retry logic
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            Task {
                await self.refreshParties()
            }
        }
    }
    
    // MARK: - Memory Management
    
    func cleanupListeners() {
        listeners.forEach { $0.remove() }
        listeners.removeAll()
        followingPartyListeners.forEach { $0.remove() }
        followingPartyListeners.removeAll()
        friendsPartyListeners.forEach { $0.remove() }
        friendsPartyListeners.removeAll()
        followingBatchParties.removeAll()
        friendsBatchParties.removeAll()
    }
    
    // MARK: - Helpers
    private func mergeBatches(_ batches: [String: [Party]]) -> [Party] {
        var byId: [String: Party] = [:]
        for (_, list) in batches {
            for party in list {
                byId[party.id] = party
            }
        }
        return Array(byId.values)
}

//  MARK: - Friend Row View
    private struct FriendRowView: View {
    let friend: UserProfile
    let status: FriendStatus
    let isLocationSharing: Bool
    let onToggleLocationSharing: () -> Void
    
    var body: some View {
        HStack(spacing: 12) {
            if let profileUrl = friend.profilePictureUrl, let url = URL(string: profileUrl) {
                AsyncImage(url: url) { image in
                        image.resizable().scaledToFill()
                    } placeholder: { Color.gray.opacity(0.3) }
                .frame(width: 40, height: 40)
                .clipShape(Circle())
            } else {
                Circle()
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 40, height: 40)
                    .overlay(
                        Text(String(friend.displayName.prefix(1)).uppercased())
                            .font(.headline)
                            .fontWeight(.medium)
                            .foregroundColor(.white)
                    )
            }
            VStack(alignment: .leading, spacing: 2) {
                HStack(spacing: 4) {
                    Text(friend.displayName)
                        .font(.subheadline)
                        .fontWeight(.medium)
                        Circle().fill(status.color).frame(width: 8, height: 8)
                    }
                HStack(spacing: 4) {
                    Text("@\(friend.username)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("â€¢ \(status.displayText)")
                        .font(.caption)
                        .foregroundColor(status.color)
                }
            }
            Spacer()
            Button(action: onToggleLocationSharing) {
                HStack(spacing: 4) {
                    Image(systemName: isLocationSharing ? "location.fill" : "location")
                        .font(.caption)
                        .foregroundColor(isLocationSharing ? .blue : .gray)
                    Text(isLocationSharing ? "Sharing" : "Share")
                            .font(.caption)
                            .foregroundColor(isLocationSharing ? .blue : .gray)
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(
                        RoundedRectangle(cornerRadius: 6)
                        .fill(isLocationSharing ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
                )
            }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
    }


    // TopicChatCard moved outside PartyDiscoveryView struct

// MARK: - Explore Section Detail View
    private struct ExploreSectionDetailView: View {
    let title: String
    let parties: [Party]
    let onJoin: (Party) -> Void
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(parties) { p in
                            PartyCard(party: p, currentLocation: nil, onJoin: { onJoin(p) }, isNearbyParty: false)
                    }
                }
                .padding(.horizontal, 0)
                .padding(.vertical, 16)
            }
            .navigationTitle(title)
                .toolbar { ToolbarItem(placement: .navigationBarTrailing) { Button("Done") { dismiss() } } }
            }
        }
    }

    // MARK: - Map Filters View
    private struct MapFiltersView: View {
        @Binding var selectedFilter: MapFilter
        let onApply: (MapFilter) -> Void
        @Environment(\.dismiss) private var dismiss
    var body: some View {
            NavigationStack {
                List {
                    ForEach(MapFilter.allCases, id: \.self) { f in
                        HStack { Text(f.displayName); Spacer(); if f == selectedFilter { Image(systemName: "checkmark") } }
                            .contentShape(Rectangle())
                            .onTapGesture { selectedFilter = f }
                    }
                }
                .navigationTitle("Map Filters")
                .toolbar { ToolbarItem(placement: .navigationBarTrailing) { Button("Apply") { onApply(selectedFilter); dismiss() } } }
            }
        }
    }

    // MARK: - Enhanced Party Detail View
    private struct EnhancedPartyDetailView: View {
        let party: Party
        let onQuickJoin: () -> Void
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationStack {
                VStack(alignment: .leading, spacing: 16) {
                    Text(party.name).font(.title2).fontWeight(.bold)
                    Text(party.hostName).font(.subheadline).foregroundColor(.secondary)
                    Spacer()
                    Button("Join", action: onQuickJoin).buttonStyle(.borderedProminent)
                }
                .padding()
                .navigationTitle("Party")
                .toolbar { ToolbarItem(placement: .navigationBarTrailing) { Button("Done") { dismiss() } } }
            }
        }
    }

}

// MARK: - Topic Chat Card (moved outside PartyDiscoveryView)
fileprivate struct TopicChatCard: View {
    let topic: TopicChat
    let onJoin: () -> Void
    private func openProfile(_ userId: String) {
        NotificationCenter.default.post(name: NSNotification.Name("OpenUserProfile"), object: userId)
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Circle()
                    .fill(topic.category.color.opacity(0.2))
                    .frame(width: 32, height: 32)
                    .overlay(Image(systemName: topic.category.icon).foregroundColor(topic.category.color).font(.system(size: 14)))
                VStack(alignment: .leading, spacing: 2) {
                    Text(topic.title).font(.headline).fontWeight(.semibold).lineLimit(1)
                    Button(action: { openProfile(topic.hostId) }) {
                        HStack(spacing: 4) {
                            Text("by").foregroundColor(.secondary)
                            Text(topic.hostName)
                                .foregroundColor(.purple)
                        }
                        .font(.caption)
                    }
                }
                Spacer()
                Button("Join", action: onJoin)
                    .font(.caption)
                    .foregroundColor(.white)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 6)
                    .background(RoundedRectangle(cornerRadius: 8).fill(topic.category.color))
            }
            Text(topic.description).font(.subheadline).foregroundColor(.secondary).lineLimit(2)
            HStack {
                Image(systemName: "person.2.fill").font(.caption).foregroundColor(.secondary)
                Text(String(topic.participants.count)).font(.caption).foregroundColor(.secondary)
                Spacer()
                Text(topic.category.displayName)
                    .font(.caption)
                    .foregroundColor(topic.category.color)
                    .padding(.horizontal, 8).padding(.vertical, 4)
                    .background(RoundedRectangle(cornerRadius: 6).fill(topic.category.color.opacity(0.1)))
            }
        }
        .padding(16)
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.05), radius: 2, x: 0, y: 1)
    }
}

// MARK: - Topic Preview View
private struct TopicPreviewView: View {
    let topic: TopicChat
    let onClose: () -> Void
    @State private var visibleParticipantCount: Int = 10
    private func openProfile(_ userId: String) {
        NotificationCenter.default.post(name: NSNotification.Name("OpenUserProfile"), object: userId)
    }
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // Header
                    HStack(alignment: .center, spacing: 12) {
                        Circle()
                            .fill(topic.category.color.opacity(0.15))
                            .frame(width: 44, height: 44)
                            .overlay(Image(systemName: topic.category.icon).foregroundColor(topic.category.color))
                        VStack(alignment: .leading, spacing: 4) {
                            Text(topic.title)
                                .font(.title2)
                                .fontWeight(.bold)
                                .lineLimit(2)
                            HStack(spacing: 8) {
                                Image(systemName: "person.fill").foregroundColor(.purple)
                                Button(action: { openProfile(topic.hostId) }) {
                                    HStack(spacing: 4) {
                                        Text("Hosted by")
                                            .foregroundColor(.purple)
                                        Text(topic.hostName)
                                            .foregroundColor(.purple)
                                            .fontWeight(.semibold)
                                    }
                                }
                                .font(.subheadline)
                            }
                        }
                        Spacer()
                        Text(topic.category.displayName)
                            .font(.caption)
                            .foregroundColor(topic.category.color)
                            .padding(.horizontal, 8).padding(.vertical, 4)
                            .background(RoundedRectangle(cornerRadius: 8).fill(topic.category.color.opacity(0.1)))
                    }

                    // Now Discussing
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Now Discussing")
                            .font(.headline)
                        if let current = topic.currentDiscussion, !current.isEmpty {
                            Text(current).foregroundColor(.secondary)
                        } else {
                            HStack(spacing: 12) {
                                Image(systemName: "text.bubble").foregroundColor(.secondary)
                                VStack(alignment: .leading) {
                                    Text("No active thread")
                                    Text("Topics will appear here")
                                        .font(.subheadline)
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                    }
                    .padding()
                    .background(RoundedRectangle(cornerRadius: 12).fill(Color(.systemGray6)))

                    // Participants
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Text("Participants")
                                .font(.headline)
                            Spacer()
                            Text("\(topic.participants.count) members")
                                .foregroundColor(.secondary)
                                .font(.subheadline)
                        }
                        ForEach(Array(topic.participants.prefix(visibleParticipantCount))) { p in
                            Button(action: { openProfile(p.id) }) {
                                HStack(spacing: 12) {
                                    Circle().fill(Color.purple.opacity(0.2)).frame(width: 36, height: 36)
                                        .overlay(Image(systemName: "person.fill").foregroundColor(.purple))
                                    VStack(alignment: .leading) {
                                        HStack(spacing: 8) {
                                            Text(p.name)
                                                .foregroundColor(.primary)
                                                .fontWeight(.medium)
                                            if p.isHost {
                                                Text("Host")
                                                    .font(.caption)
                                                    .padding(.horizontal, 6).padding(.vertical, 2)
                                                    .background(RoundedRectangle(cornerRadius: 6).fill(Color.yellow.opacity(0.3)))
                                            }
                                        }
                                        Text("Joined just now")
                                            .font(.caption)
                                            .foregroundColor(.secondary)
                                    }
                                    Spacer()
                                }
                                .padding(12)
                                .background(RoundedRectangle(cornerRadius: 10).fill(Color(.systemGray6)))
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                        if topic.participants.count > visibleParticipantCount {
                            Button(action: { visibleParticipantCount = min(visibleParticipantCount + 10, topic.participants.count) }) {
                                HStack {
                                    Text("See More")
                                    Image(systemName: "chevron.down")
                                }
                                .frame(maxWidth: .infinity)
                            }
                            .buttonStyle(.plain)
                            .padding(.top, 4)
                        }
                    }

                    // Stats
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Topic Stats").font(.headline)
                        HStack {
                            statTile(title: "Members", value: String(topic.participants.count))
                            statTile(title: "Speakers", value: String(topic.speakers.count))
                            statTile(title: "Voice Chat", value: topic.voiceChatActive ? "On" : "Off")
                        }
                    }

                    // Join Button
                    VStack(alignment: .leading, spacing: 8) {
                        Button(action: { /* hook up when implementing joining */ }) {
                            HStack {
                                Image(systemName: "person.2.fill")
                                Text("Join Discussion")
                                    .fontWeight(.semibold)
                            }
                            .frame(maxWidth: .infinity)
                        }
                        .buttonStyle(.borderedProminent)
                        Text("You'll be able to chat with others and request to speak")
                            .font(.footnote)
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity, alignment: .center)
                    }
                }
                .padding()
            }
            .navigationTitle("Discussion Preview")
            .toolbar { ToolbarItem(placement: .navigationBarTrailing) { Button("Close") { onClose() } } }
        }
    }

    private func statTile(title: String, value: String) -> some View {
        VStack(spacing: 6) {
            Text(value).font(.title3).fontWeight(.semibold)
            Text(title).font(.caption).foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(RoundedRectangle(cornerRadius: 12).fill(Color(.systemGray6)))
    }
}

// MARK: - Filter Sheet View
struct FilterSheetView: View {
    @Binding var selectedFilter: PartyFilter
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Filter Options
                VStack(alignment: .leading, spacing: 20) {
                    // Sort By Section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Sort By")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .padding(.horizontal, 16)
                        
                        LazyVGrid(columns: [
                            GridItem(.flexible()),
                            GridItem(.flexible())
                        ], spacing: 12) {
                            ForEach(PartyFilter.allCases, id: \.self) { filter in
                                FilterOptionCard(
                                    title: filter.rawValue,
                                    icon: filter.icon,
                                    isSelected: selectedFilter == filter
                                ) {
                                    selectedFilter = filter
                                }
                            }
                        }
                        .padding(.horizontal, 16)
                    }
                }
                .padding(.vertical, 20)
                
                Spacer()
                
                // Apply Button
                Button(action: {
                    dismiss()
                }) {
                    Text("Apply Filters")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(Color.blue)
                        .cornerRadius(12)
                }
                .padding(.horizontal, 16)
                .padding(.bottom, 20)
            }
            .navigationTitle("Filters")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Reset") {
                        selectedFilter = .normal
                    }
                    .foregroundColor(.red)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - Filter Option Card
struct FilterOptionCard: View {
    let title: String
    let icon: String
    let isSelected: Bool
    let onTap: () -> Void
    
    var body: some View {
        Button(action: onTap) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(isSelected ? .white : .blue)
                
                Text(title)
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(isSelected ? .white : .primary)
                    .multilineTextAlignment(.center)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.blue : Color(.systemGray6))
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}


